00001419 __cxa_finalize
00001428 __cxa_atexit
00001435 ahpl_mpq_create
00001445 _Znwm
0000144b _ZdlPv
00001452 _ZNSt6__ndk119__shared_weak_count14__release_weakEv
00001486 __cxa_pure_virtual
00001499 ahpl_log
000014a2 _ZNSt6__ndk119__shared_weak_countD2Ev
000014c8 ahpl_ref_create
000014d8 _ZdaPv
000014df _Znam
000014e5 _ZNKSt6__ndk119__shared_weak_count13__get_deleterERKSt9type_info
00001526 ahpl_mpq_destroy_wait
0000153c ahpl_module_register
00001551 ahpl_mpq_run_func_done_qid
0000156c ahpl_module_unregister
00001583 ahpl_mpq_queue_args
00001597 __stack_chk_fail
000015a8 free
000015ad malloc
000015b4 puts
000015b9 _ZSt18uncaught_exceptionv
000015d3 strlen
000015da __cxa_guard_acquire
000015ee __cxa_guard_release
00001602 fclose
00001609 fopen
0000160f fwrite
00001616 memchr
0000161d memcmp
00001624 dlclose
0000162c dlopen
00001633 dlsym
00001639 __errno
00001641 ioctl
00001647 mmap
0000164c munmap
00001653 strerror
0000165c putchar
00001664 libagora-rtc-sdk.so
00001678 libagora-core.so
00001689 libm.so
00001691 libdl.so
0000169a liblog.so
000016a4 _ZSt9terminatev
000016b4 __cxa_begin_catch
000016c6 __gxx_personality_v0
000016db clock_gettime
000016e9 _Unwind_Resume
000016f8 _ZNKSt13runtime_error4whatEv
00001715 _ZTVN10__cxxabiv117__class_type_infoE
0000173b _ZTVN10__cxxabiv120__si_class_type_infoE
00001764 _ZTVN10__cxxabiv121__vmi_class_type_infoE
0000178e __cxa_allocate_exception
000017a7 __cxa_end_catch
000017b7 __cxa_free_exception
000017cc __cxa_rethrow
000017da __cxa_throw
000017e6 realloc
000017ee wmemcpy
000017f6 __sF
000017fb fflush
00001802 ungetc
00001809 _ZNSt11logic_errorC2EPKc
00001822 _ZNSt12length_errorD1Ev
0000183a _ZNSt13runtime_errorC1EPKc
00001855 _ZNSt13runtime_errorD1Ev
0000186e _ZNSt6__ndk111__call_onceERVmPvPFvS2_E
00001895 _ZNSt6__ndk114__shared_count12__add_sharedEv
000018c2 _ZNSt6__ndk114__shared_count16__release_sharedEv
000018f3 _ZNSt6__ndk114__shared_countD2Ev
00001914 _ZNSt8bad_castC1Ev
00001927 _ZNSt8bad_castD1Ev
0000193a _ZSt17__throw_bad_allocv
00001953 _ZTINSt6__ndk114__shared_countE
00001973 _ZTISt12length_error
00001988 _ZTISt13runtime_error
0000199e _ZTISt8bad_cast
000019ae _ZTVSt12length_error
000019c3 __ctype_get_mb_cur_max
000019da __cxa_guard_abort
000019ec freelocale
000019f7 islower
000019ff isupper
00001a07 iswalpha
00001a10 iswblank
00001a19 iswcntrl
00001a22 iswdigit
00001a2b iswlower
00001a34 iswprint
00001a3d iswpunct
00001a46 iswspace
00001a4f iswupper
00001a58 iswxdigit
00001a62 isxdigit
00001a6b mbrlen
00001a72 mbrtowc
00001a7a mbsnrtowcs
00001a85 mbsrtowcs
00001a8f mbtowc
00001a96 newlocale
00001aa0 strcoll
00001aa8 strftime
00001ab1 strtod
00001ab8 strtof
00001abf strtold_l
00001ac9 strtoll_l
00001ad3 strtoull_l
00001ade strxfrm
00001ae6 tolower
00001aee toupper
00001af6 towlower
00001aff towupper
00001b08 uselocale
00001b12 vasprintf
00001b1c vsnprintf
00001b26 vsscanf
00001b2e wcrtomb
00001b36 wcscoll
00001b3e wcsnrtombs
00001b49 wcsxfrm
00001b51 wmemset
00001b59 wcslen
00001b60 wmemmove
00001b69 _ZNSt13runtime_errorC2ERKNSt6__ndk112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
00001bc6 _ZNSt13runtime_errorD2Ev
00001bdf strerror_r
00001bea _ZNSt6__ndk117__assoc_sub_state12__make_readyEv
00001c1a _ZNSt6__ndk118condition_variable10notify_allEv
00001c49 _ZNSt6__ndk15mutex6unlockEv
00001c65 nanosleep
00001c6f pthread_detach
00001c7e pthread_join
00001c8b pthread_key_create
00001c9e sysconf
00001ca6 libc.so
00001cae libagora_super_resolution_extension.so
00001cd5 LIBC
00009647 Ri2"
000096d9 j)8`j
0000970f *h""
00009714 uj)x`j
0000975d j)8kj*x`j
00009767 <u.+
0000979b *h23
000097e7 <t><
00009823 *ij(
00009863 *ij(
00009887 Rij(
0000989b Rij(x
000098fb *ij(
00009907 <vj-
00009947 *ij(
00009953 <nj-
0000998f *ij(
000099d7 *ij(
00009a1f *ij(
00009a67 *ij(
00009aaf *ij(
00009af7 *ij(
00009b3f *ij(
00009b83 *ij(
00009bc3 *ij(
00009c03 *ij(
00009c43 *ij(
00009c87 *ij(
00009c93 <uj-
00009ccf *ij(
00009cdb <vj-
00009d17 *ij(
00009d23 <vj-
00009d5f *ij(
00009d6b <vj-
00009dab *ij(
00009db7 <wj-
00009df3 *ij(
00009dff <vj-
00009e3f *ij(
00009e8f *ij(
00009eb7 Rij(
00009ecf rxj)x
00009f4f *ij(
00009f5b <uj-
00009fa7 *ij(
00009fb3 <uj*
0000a007 *ij(
0000a05f *ij(
0000a06b <uj*
0000a0bb *ij(
0000a0c7 <uj-
0000a0e7 Rij(
0000a10f Rxj)x
0000a137 <uj*
0000a17f *ij(
0000a1d7 *ij(
0000a1e3 <uj-
0000a233 *ij(
0000a23f <uj-
0000a25f Rij(
0000a27b Rij(x
0000a2b3 *wj(
0000a2cb RJ5:
0000a2eb rhj)
0000a31b <vj)
0000a36b *ij(
0000a377 <wj-
0000a3cb *ij(
0000a3d7 <wj.
0000a427 *ij(
0000a433 <wj-
0000a453 Rij(
0000a497 *uj(
0000a4e7 *ij(
0000a4f3 <uj-
0000a543 *ij(
0000a54f <wj-
0000a56f Rij(
0000a58b Rij(x
0000a60b *ij(
0000a667 *ij(
0000a66c kj*xaj
0000a693 Rij(
0000a6af Rij(x
0000a72f *ij(
0000a78b *ij(
0000a7b7 Rij(
0000a7d3 Rij(x
0000a833 Rhj)
0000a84f <tj(
0000aa2f 7		@
0000aa9d j48S
0000aae9 C@9h
0000ab6d cA9H
0000ae85 aQ9h
0000b4df 7i>@
0000b4f1 [C)Z
0000b503 ThB@
0000b66b <i.@
0000be4c vVE)
0000c309 	@9U
0000c8a1 j88K
0000c8cd j88@
0000c8f9 j885
0000c913 9hjw8
0000c91b qhj;8hj88+8
0000ca3d kv8)	
0000ca85 js8)
0000cacb 9hks8hk)8hk68+
0000cc01 (HO-(HON(HOo(HO, YOM YOn YO
0000cc1d  YOL(iOm(iO
0000cc2d (iOl zO
0000ce23 *+}C
0000ce9b x|jm8>km8ukm8
0000ceb8 ujn8
0000cec4 |kn8>
0000cecb y'kn8
0000cedc |jp8
0000cee8 5kp8wkp8
0000cef5 hp8'
0000cf00 ujq8
0000cf08 7kq8
0000cf10 |kq8
0000cf2b ysj`85k`8wk`8
0000cf8c Ok!8
0000cf9a Aq1~
0000cfa0 Pk/8
0000cfc8 Qk!8
0000cfd0 Ok-8
0000d21a `N)A
0000d229 (!n?
0000d33a pN%@
0000d362 (.B@
0000d3ae `NB(!.kA
0000d3ba `Nc(!."(!n
0000d4ea pN%@
0000d512 (.B@
0000d55e `NB(!.JA
0000d56a `Nc(!."(!n
0000d579 (!n_
0000d696 `N)A
0000d6a5 (!n?
0000d831 (!.$
0000d9a1 0@9h
0000dafc h2@9
0000db55 2@9(
0000db5b 4($@
0000dc1b =!	@
0000dc94 h6E9	
0000dd7f =V	@
0000dddf <h&R
0000e3ad /E9H
0000e79d 7E9+
0000e880 ?k88
0000e900 ?k88
0000e919 cA9h
0000e997 7(	@
0000e9dc h?E9
0000ec89 k68h
0000ed3e @9(	
0000ed43 4h2@
0000ed4f T`.@
0000eec3 4h.E9
0000eecb 4h6E9h
0000eed3 4h:E9
0000eedb 4hBE9
0000f048 hB@9
0000f3a9 uC9?
0000f521 uC9<}@
0000fac4 aBE9b>E9
0000fae8 h.E9`b@
0000fb18 h.E9`f@
0000fb40 h.E9`j@
0000fba4 jBE9
0000fcc0 jBE9
0000fdc0 jBE9
0000ff5c h.E9`b@
0000ff8c h.E9`f@
0000ffb4 h.E9`j@
00010099 j48h
00010289 %@9H
00010402 	*[B
00010425 %@9H
00010588 ?k78h
000106d1 %@9H
0001074f 5@E@
000107e1 %@9H
00010a3c hc@9i+B
00010c9b 7		@
00010f0f =V	@
00010f6f <h&R
000111d4 hFE9
00011388 h6E9
00011397 4h:E9
000113b4 h.E9H
000113c8 i>E9hBE9i
000113ec h.E9H
00011751 #C9h
00011818 ?k88
00011897 *?k88
000118b1 #A9h
0001192d #C9H
00011940 h>E9
00011b78 hB@9h
00011bd9 uC9?
00011d0d uC9;}@
000120f1 >E9a
000127c8 iFE9?
000127ec h.E9
000129ac h6E9
000129bb 4h:E9
000129d8 h.E9H
000129ec i>E9hBE9
00012a10 h.E9H
00012cb9 CB9u
00012d9d CB9h
00012dbd cC9h
00012e8c ?k88
00012f0c ?k88
00012f25 cA9h
00012fc0 h>E9
000130ab 4h.E9
000130b3 4h6E9h
000130bb 4h:E9H
000132d0 hB@9h
000134d1 uC9?
00013569 .E9(
0001364d uC9:}@
0001424f =V	@
000142af <h&R
000145c8 iFE9?
000145ec h.E9
000147a4 h6E9
000147b3 4h:E9
000147d0 h.E9H
000147e4 i>E9hBE9
00014808 h.E9H
00014ab1 CB9u
00014b95 CB9h
00014bb5 cC9h
00014d0c ?k88
00014d8b *?k88a
00014da5 cA9h
00014e15 cC9(
00014e28 h>E9
00014f13 4h.E9
00014f1b 4h6E9h
00014f23 4h:E9
00015060 hB@9h
000151f5 uC9?
0001536d uC9:}@
00015859 BE9h
00016590 A5!.,<
000165cb 7,<	
00016637 9,<	
000176d9 CB9	
0001776e B9	+K
00017b4d #H9h
00017dc3 7h~A
00017e65 #H9h
00017fc3 T`"@
00018457 Thz@
000184d6 @9`&@
000187a5 j(86
00018a08 h"@9
00018e45 %@9H
00018ffd %@9H
0001915f Tt"@
0001a0af Th{u
0001a187 Th{u
0001a2b3 9 !@
0001a3a8 h"@9i
0001a46c _k88
0001a4bc h"@9j&A
0001a5fb Tj~@
0001a67f Tj~@
0001a794 	@D9,|@
0001a857 2L}@
0001a95c *aC97
0001ac29 #@9h
0001b049 %@9H
0001b1f7 Ti~@
0001b20f TjJ@
0001dbe0 hr@9
0001dc9b 7hr@9
0001dcb0 hr@9(
0001dd6b 7hr@9
0001de44 hr@9
0001e1f7 7		@
0001e29f 7		@
0001e3d3 7		@
0001e82b Tt^@
0001e998 hB@9
0001ea3f 7h"@9
0001ea70 h"@9
0001eacb 7hBB9
0001eadb 6`F@
0001eaec h"@9(
0001eb0f 6`^@
0001eb18 hBB9
0001eb1f 6`R@
0001ee54 d*E9
0001eedd c@9j
0001f1dc d*E9
0001f2f4 h"E9`
0001f310 h&E9
0001f355 xC9hF
0001f393 7(	@
0001f427 9hB@9
0001f723 Th^A
0001f737 T`^@
0001f76b 6h*E9`^@
0001f787 RA|@
0001f7ac h*E9`^@
0001f817 2 yh
0001f837 2 yh
0001f873 ThzA
0001f8d0 i*E9
0001f918 i*E9
0001f950 h&Aij
0001f983 2 yh
0001f9fb ThZA
0001fa0b Th^A
0001fa2b TifA
0001fa74 hB@9h
0001fb24 h6E9(
0001fb2b 4`^@
0001fb4c hNE9
0001fb56 @)`^@
0001fb7c j&E98
0001fc50 a"E9
0001fcad *@)hzA
0001fd4f 7hRE9
0001fd57 5hJE9
0001fd78 h"E9
0001fdab ThJE9h
0001fdc8 c*E9h
0001ffcb k(|@
00020311 'C)J
0002038b TK|@
000203af Sj|@
00020509 j`8Gjz8
00020541 jz8^jz8
00020563 8Pjz8
00020577 8Mjz8
0002057d jz8k}
0002062f RI|@
000207dd Ha.9
00020805 Jan0
00020831 Ja.RJa.
00020843 nsJa.
00020849 Ja.0Jan
00020871 J!.fJ!.
00020884 DJ!.
000208cc Whu8}h|8
00020944 Xhu8
0002097d h;8Qhu8
000209bc qj98xj:8wj;8
00020aae 	2  !
00020b8e 	kg[
00020bc7 rf6F*u:
00020cae 	2AZ
00020cc8 16R*
0002153b 5 E@
0002180b =a	@
000221a3 4`^@
000221eb T k58
00022211 s@9`^
0002226b Th*@
0002227b T`"@
000222a6 _8a"@
0002251f 4`^@
00022567 T k58
000225e7 Th*@
000225f7 T`"@
00022622 _8a"@
00022fb8 h @9
000230c9 #@9H
00023492 @9_	
0002390d cA9m
00023a0d cA9h
00023ab1 cA9h
00023db1 cA9m
00023eb1 cA9h
00023f55 cA9h
00024255 cA9m
00024355 cA9h
000243f9 cA9h
000246f9 cA9m
000247f9 cA9h
0002489d cA9h
00024b9d cA9m
00024c9d cA9h
00024d41 cA9h
00025041 cA9m
00025141 cA9h
000251e5 cA9h
0002535d cA9h
000255b9 cA9h
000257e5 cA9h
00025a41 cA9h
00025c6d cA9h
00025ec9 cA9h
00026271 #A9h
00026341 #A9H
0002635d #A9h
00026385 #A9h
00026409 a@9_
000266b7 *jij8+
000266ff *jij8+
00026874 h @9
00026985 #@9H
00026d42 @9_	
000271f1 cA9m
00027339 cA9h
000273b5 cA9h
000276d9 cA9m
00027821 cA9h
0002789d cA9h
00027bc1 cA9m
00027d09 cA9h
00027d85 cA9h
000280a9 cA9m
000281f1 cA9h
0002826d cA9h
00028591 cA9m
000286d9 cA9h
00028755 cA9h
00028a79 cA9m
00028bc1 cA9h
00028c3d cA9h
00028dd9 cA9h
00029079 cA9h
000292a1 cA9h
00029541 cA9h
00029769 cA9h
00029a09 cA9h
00029df5 CA9h
00029e9d CA9H
00029eb9 CA9h
00029ee1 CA9h
0002a213 *jij8+
0002a25b *jij8+
0002a4a8 m	@9
0002a530 m!@9
0002a544 m%@9
0002a558 m)@9
0002a56c m-@9
0002a580 m1@9
0002a594 m5@9
0002a5a8 m9@9
0002a5bc m=@9
0002a5d0 mA@9
0002a5e4 mE@9
0002a5f8 mI@9
0002a60c mM@9
0002a620 mQ@9
0002a634 mU@9
0002a648 mY@9
0002a65c m]@9
0002a670 ma@9
0002a684 me@9
0002a698 mi@9
0002a6ac mm@9
0002a6c0 mq@9
0002a6d4 mu@9
0002a6e8 my@9
0002a6fc m}@9
0002a734 kil8
0002afc0 H @9h
0002b678 )ih8	
0002c780 )ih8	
0002d040 H @9h
0002d618 )ih8	
0002e7bc )ih8	
0002f1b3 *)%@
0002f1e0 	ii8
0002f3c5 ii8H
0002fdd5 b@9I
0002fe59 b@9	
0002ffe5 ii8h
0003073f *(5@
00031371 b@9I
000313f5 b@9	
000324fc Chc8
00032bd4 jIj8
00032c03 7k	@
00032c10 lij8
00032c3c nin8
00032d71 ii8H>
000333f5 #C9*
00033511 #C9*
00033799 cB9h
000337b1 #C9h
000338a5 cB9(
000338e5 cB9h
000340cc "hb8
000347e9 Ij8_
000350a1 #C9*
000351bd #C9*
0003543d cB9(
0003545d cB9h
00035475 #C9h
0003559d cB9h
000355b5 #C9h
00035ee1 cB9H
000363b8 Iii8
0003698d CB9h
00036a51 CB9h
00036a89 CB9h
00036e7d CB9H
000371c4 hj|8
000373e2 ;*_	
000376eb TmE@
000379a9 CB9h
00037a6d CB9h
00037aa5 CB9h
00037b77 2JaG
000382c7 R)uF
00039b43 T+yk
00039b87 T	yi
00039bc7 T	yi
00039fb3 nB(a
00039feb T*E@
0003a034 hb@9H
0003a078 hb@9H
0003a4b4 C4!NC
0003b11b T+}L
0003b143 TK-@xl
0003b1f8 ?9@qc
0003b75d 	@9_
0003b84b TJ	n
0003ba9b T		@9?
0003bc23 TK	n
0003bc33 SK-@
0003bf0f TJ	n
0003bf69 `@9)uF
0003bfa9 `@9)uF
0003bff1 `@9)
0003c031 `@9)
0003e38f Ti		
0003f5bb =!	@
0003f68f =!	@
0003fb8d #@9h
0003fbf5 #@9h
0003fc0d #@9h
0003fc8d #@9h
0003fce5 #@9h
0003fcfd #@9h
0003ff9d #@9h
00040009 #@9h
00040021 #@9h
000400b1 #@9h
0004010d #@9h
00040125 #@9h
00040443 TtV@
000408c4 SuperResolutionQ
000408d5 %s sr type %d. res %d
000408eb init
000408f0 super resolution deInit done.
0004090e super resolution initializing.
0004092d init super resolution with async worker
00040955 SuperResolutionWarmup
0004096b super resolution worker busy with warm up.
00040996 super resolution params changed. do warm up.
000409c3 super resolution process Error!!!
000409e5 agora_super_resolution_extension
00040a06 argc=%ld, argv [0](buffer)=%p
00040a25 %s srtype %d. not support type
00040a44 setSRType
00040a4e %s srtype %d.
00040a5c %s init result:%d , sr version: %s 
00040a80 operator()
00040a8b super resolution warm up finish
00040ad0 modelidx_in set to %d
00040ae7 superres_release_1.4.1_23fa2c97d_20220309T154529
00040b20 sr not initialized!
00040b50 M!P?O
00040b67 B_b_quant is %d
00040b78 --_cl_engine->CompileSource
00040b94 sr_kernel_version_
00040ba7 __kernel void 
00040bb6 (__global float *a) { } 
00040bd3  #define USE_IMAGE 
00040beb  #define QUANT 1 
00040c01  #define QUANT 0 
00040c17  #define USE_BUFFER_OUT 
00040c32 sr_conv_3x3_s1x1_n8_c1
00040c49 sr_conv_3x3_s1x1_n8_c8_prelu
00040c66 sr_conv_3x3_s1x1_n4_c8
00040c7d sr_deconv_4x4_s2x2_n1_c4_resize_2x2_add
00040ca5 sr_deconv_4x4_s2x2_n1_c4
00040cbe sr_resize_2x2_add
00040cd0 conv0
00040cd6 conv2
00040cdc conv4
00040ce2 deconv5
00040cea upsampler6
00040cf5 in stride is %d, out stride is %d
00040d18 _b_use_buffer_out is %d, _b_use_subgroup8 is %d
00040d49 2x high model Not Initialized!
00040d68  cost:   
00040d75 --min cost: 
00040d86  max cost: 
00040d92  avg cost: 
00040dc0 CL Engine Init error!
00040de0 CL CompileSource error!
00040e00 add kernel of prelu 2x model on qcom
00040e30 quant prelu net params updated
00040e50 Create input ION image failed, so use normal image 
00040e90 Create ION buffer failed, so use normal buffer 
00040ec0 Create ION buffer successfully 
00040ee0 Create input ION image successfully 
00040f08 io buf 1 failed
00040f20 sr_deconv_4x4_s2x2_n4_c4
00040f39 sr_conv_3x3_s1x1_n1_c4
00040f50 sr_conv_2x2_s1x1_n1_c2
00040f67 deconv1
00040f90 add kernel of 2x tiny model on non-qom and non-g76/52 devices 
00040fd0 add kernel of 2x tiny model on mali g52&76
00041000 add kernel of 2x tiny model on qcom
0004103d *]>sr_deconv_5x5_s3x3_n1_c4
00041059 sr_resize_3x3_add
0004106b deconv6
00041073 upsampler7
000410a0 add kernel of prelu 3x model on normal platform
000410d0 add kernel of prelu 3x model on mali subgroup
00041100 add kernel of prelu 3x model on qcom
00041130 quant 3x high net params updated
00041167 >deconv3
00041170 upsampler4
000411a0 3x low net params updated
000411c0 quant 3x low net params updated
000411e2  #define EMPTY_KERNEL ; 
000411fc  #ifdef HALF_FP 
0004120e  #pragma OPENCL EXTENSION cl_khr_fp16 : enable 
0004123f  #define DATA_TYPE half 
00041259  #define DATA_TYPE2 half2 
00041275  #define DATA_TYPE3 half3 
00041291  #define DATA_TYPE4 half4 
000412ad  #define DATA_TYPE8 half8 
000412c9  #define DATA_TYPE16 half16 
000412e7  #define WRITE_IMAGE write_imageh 
0004130b  #define READ_IMAGE read_imageh 
0004132d  #define VLD8 vload8 
00041344  #define VLD4 vload4 
0004135b  #define VLD2 vload2 
00041372  #define VLD3 vload3 
00041389  #define VLD vload_half 
000413a3  #define VST(a, offset, p) *(p + offset) = a; 
000413d3  #define VST2 vstore2 
000413eb  #define VST3 vstore3 
00041403  #define VST4 vstore4 
0004141b  #define CONVERT convert_half 
0004143b  #define CONVERT3 convert_half3 
0004145d  #define CONVERT4 convert_half4 
0004147f  #define CONVERT8 convert_half8 
000414a1  #define UGENTYPE4 ushort4 
000414be  #define UGENTYPE8 ushort8 
000414db  #define UGENTYPE16 ushort16 
000414fa  #else 
00041503  #define DATA_TYPE float 
0004151e  #define DATA_TYPE2 float2 
0004153b  #define DATA_TYPE3 float3 
00041558  #define DATA_TYPE4 float4 
00041575  #define DATA_TYPE8 float8 
00041592  #define DATA_TYPE16 float16 
000415b1  #define WRITE_IMAGE write_imagef 
000415d5  #define READ_IMAGE read_imagef 
000415f7  #define VLD8 vload_half8 
00041613  #define VLD4 vload_half4 
0004162f  #define VLD2 vload_half2 
0004164b  #define VLD3 vload_half3 
00041667  #define VLD vload_half 
00041681  #define VST vstore_half 
0004169c  #define VST2 vstore_half2 
000416b9  #define VST3 vstore_half3 
000416d6  #define VST4 vstore_half4 
000416f3  #define CONVERT convert_float 
00041714  #define CONVERT3 convert_float3 
00041737  #define CONVERT4 convert_float4 
0004175a  #define CONVERT8 convert_float8 
0004177d  #define UGENTYPE4 uint4 
00041798  #define UGENTYPE8 uint8 
000417b3  #define UGENTYPE16 uint16 
000417d0  #endif 
000417da  #ifdef QUALCOMM 
000417ed  #define __ATTRIBUTE_MAX_CONSANT_SIZE_(size) __attribute__((max_constant_size(size))) 
00041845  #else 
0004184e  #define __ATTRIBUTE_MAX_CONSANT_SIZE_(size) 
0004187d  #endif 
00041887 #define GLOBAL_WORK_GROUP_SIZE_DIM2 \
000418ad  __private const short global_size_dim0, __private const short global_size_dim1 \
00041902 #define GLOBAL_WORK_GROUP_SIZE_DIM3 \
00041928  __private const short global_size_dim0, __private const short global_size_dim1, __private const short global_size_dim2 \
000419a5  #ifdef USE_BUFFER_OUT 
000419be  #define OUT_TYPE __global DATA_TYPE * 
000419e7  #else 
000419f0  #define OUT_TYPE write_only image2d_t 
00041a19  #endif 
00041a23  #define READ_IMAGEX0(srcImg, sampler, pos) (DATA_TYPE4)(0.35f, 0.12f, 0.45f, 0.66f) 
00041a7a  #define READ_IMAGEX1(srcImg, sampler, pos) (DATA_TYPE4)(0.11f, 0.62f, 0.15f, 0.46f) 
00041ad1  #define READ_IMAGEX2(srcImg, sampler, pos) (DATA_TYPE4)(0.25f, 0.32f, 0.45f, 0.36f) 
00041b28  #define READ_IMAGEX3(srcImg, sampler, pos) (DATA_TYPE4)(0.85f, 0.72f, 0.45f, 0.56f) 
00041b7f  #define VLD8X0(offset, p) (DATA_TYPE8)(1.3f, 0.10f, 0.33f, 0.45f, 1.2f, 0.12f, 0.43f, 0.45f) 
00041bdf  #define VLD8X1(offset, p) (DATA_TYPE8)(1.1f, 0.11f, 0.13f, 0.25f, 2.2f, 0.32f, 0.41f, 0.41f) 
00041c3f  #define VLD4X0(offset, p) (DATA_TYPE4)(1.3f, 0.10f, 0.33f, 0.45f) 
00041c84  #define VLD4X1(offset, p) (DATA_TYPE4)(1.1f, 0.11f, 0.13f, 0.25f) 
00041cc9  #define VLD4X2(offset, p) (DATA_TYPE4)(1.4f, 0.20f, 0.43f, 0.55f) 
00041d0e  #define VLD4X3(offset, p) (DATA_TYPE4)(1.5f, 0.31f, 0.13f, 0.25f) 
00041d53  #define VLD16 vload16 
00041d6c  #define VLD16X(pos, ptr) (uchar16)(3, 5, 6, 8, 4, 9, 11, 13, 3, 5, 6, 18, 24, 29, 31, 43) 
00041dc9  #define prelu8(a, x) fmax(x,(DATA_TYPE8)(0.0f)) + a * fmin(x, (DATA_TYPE8)(0.0f)) 
00041e1f __kernel void sr_conv_3x3_s1x1_n8_c1(__global unsigned char* srcImg, OUT_TYPE dstImg, __constant half *weight_bias_3x3 __ATTRIBUTE_MAX_CONSANT_SIZE_(80 * sizeof(half)), __constant half *weight_bias_1x1 __ATTRIBUTE_MAX_CONSANT_SIZE_(36 * sizeof(half)), int width, int height, int stride_in, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0) << 2); int y = get_global_id(1); DATA_TYPE8 output[4]; DATA_TYPE8 w; int pos; DATA_TYPE8 in, in1, in2, in3; if (x < width && y < height) { output[0] = VLD8(9, weight_bias_3x3); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE8 weight[3]; uchar8 pix = (uchar8)(0); int pos_y = y + i - 1; if (pos_y<0 || pos_y>height - 1) continue; int pos = mad24(pos_y, stride_in, x); if (x > 0) pix.s0 = srcImg[pos - 1]; pix.s1234 = vload4(0, srcImg + pos); if (x + 4 < width) pix.s5 = srcImg[pos + 4]; in = CONVERT8(pix); in *= (DATA_TYPE)(1.0f / 255.0f); weight[0] = VLD8(i * 3 + 0, weight_bias_3x3); weight[1] = VLD8(i * 3 + 1, weight_bias_3x3); weight[2] = VLD8(i * 3 + 2, weight_bias_3x3); output[0] = mad(weight[0], in.s0, output[0]); output[1] = mad(weight[0], in.s1, output[1]); output[2] = mad(weight[0], in.s2, output[2]); output[3] = mad(weight[0], in.s3, output[3]); output[0] = mad(weight[1], in.s1, output[0]); output[1] = mad(weight[1], in.s2, output[1]); output[2] = mad(weight[1], in.s3, output[2]); output[3] = mad(weight[1], in.s4, output[3]); output[0] = mad(weight[2], in.s2, output[0]); output[1] = mad(weight[2], in.s3, output[1]); output[2] = mad(weight[2], in.s4, output[2]); output[3] = mad(weight[2], in.s5, output[3]); } in = fmax(output[0], (DATA_TYPE8)(0.0f)); in1 = fmax(output[1], (DATA_TYPE8)(0.0f)); in2 = fmax(output[2], (DATA_TYPE8)(0.0f)); in3 = fmax(output[3], (DATA_TYPE8)(0.0f)); output[0].lo = VLD4(8, weight_bias_1x1); output[0].hi = output[0].lo; output[1] = output[0]; w = VLD8(0, weight_bias_1x1); output[0].lo = mad(w.lo, in.s0, output[0].lo); output[0].hi = mad(w.lo, in1.s0, output[0].hi); output[1].lo = mad(w.lo, in2.s0, output[1].lo); output[1].hi = mad(w.lo, in3.s0, output[1].hi); output[0].lo = mad(w.hi, in.s1, output[0].lo); output[0].hi = mad(w.hi, in1.s1, output[0].hi); output[1].lo = mad(w.hi, in2.s1, output[1].lo); output[1].hi = mad(w.hi, in3.s1, output[1].hi); w = VLD8(1, weight_bias_1x1); output[0].lo = mad(w.lo, in.s2, output[0].lo); output[0].hi = mad(w.lo, in1.s2, output[0].hi); output[1].lo = mad(w.lo, in2.s2, output[1].lo); output[1].hi = mad(w.lo, in3.s2, output[1].hi); output[0].lo = mad(w.hi, in.s3, output[0].lo); output[0].hi = mad(w.hi, in1.s3, output[0].hi); output[1].lo = mad(w.hi, in2.s3, output[1].lo); output[1].hi = mad(w.hi, in3.s3, output[1].hi); w = VLD8(2, weight_bias_1x1); output[0].lo = mad(w.lo, in.s4, output[0].lo); output[0].hi = mad(w.lo, in1.s4, output[0].hi); output[1].lo = mad(w.lo, in2.s4, output[1].lo); output[1].hi = mad(w.lo, in3.s4, output[1].hi); output[0].lo = mad(w.hi, in.s5, output[0].lo); output[0].hi = mad(w.hi, in1.s5, output[0].hi); output[1].lo = mad(w.hi, in2.s5, output[1].lo); output[1].hi = mad(w.hi, in3.s5, output[1].hi); w = VLD8(3, weight_bias_1x1); output[0].lo = mad(w.lo, in.s6, output[0].lo); output[0].hi = mad(w.lo, in1.s6, output[0].hi); output[1].lo = mad(w.lo, in2.s6, output[1].lo); output[1].hi = mad(w.lo, in3.s6, output[1].hi); output[0].lo = mad(w.hi, in.s7, output[0].lo); output[0].hi = mad(w.hi, in1.s7, output[0].hi); output[1].lo = mad(w.hi, in2.s7, output[1].lo); output[1].hi = mad(w.hi, in3.s7, output[1].hi); 
00042c54  #ifdef USE_BUFFER_OUT 
00042c6d  pos = mad24(y, stride_out, x << 2); vstore8(output[0], 0, dstImg + pos); vstore8(output[1], 1, dstImg + pos); 
00042cde  #else 
00042ce7  WRITE_IMAGE(dstImg, (int2)(x + 0, y), output[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), output[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y), output[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y), output[1].hi); 
00042dbe  #endif 
00042dc8  } }
00042dcd __kernel void sr_deconv_4x4_s2x2_n4_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(68 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1); DATA_TYPE8 out[2]; DATA_TYPE8 w; DATA_TYPE4 in[4]; if (x < width && y < height) { out[0].lo = VLD4(16, weight_bias); out[0].hi = out[0].lo; out[1] = out[0]; int i_start = (y & 1); int offset = i_start * 2; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in[0] = READ_IMAGE(srcImg, sampler, (int2)((x - 2) >> 1, pos_y)); in[1] = READ_IMAGE(srcImg, sampler, (int2)((x + 0) >> 1, pos_y)); in[2] = READ_IMAGE(srcImg, sampler, (int2)((x + 2) >> 1, pos_y)); in[3] = READ_IMAGE(srcImg, sampler, (int2)((x + 4) >> 1, pos_y)); w = VLD8(offset + 0, weight_bias); out[0].lo = mad(w.lo, in[0], out[0].lo); out[0].hi = mad(w.hi, in[1], out[0].hi); out[1].lo = mad(w.lo, in[1], out[1].lo); out[1].hi = mad(w.hi, in[2], out[1].hi); w = VLD8(offset + 1, weight_bias); out[0].lo = mad(w.lo, in[1], out[0].lo); out[0].hi = mad(w.hi, in[2], out[0].hi); out[1].lo = mad(w.lo, in[2], out[1].lo); out[1].hi = mad(w.hi, in[3], out[1].hi); offset += 4; } 
000432ef  #ifdef USE_BUFFER_OUT 
00043308  int pos = mad24(y, stride, x << 2); vstore8(out[0], 0, dstImg + pos); vstore8(out[1], 0, dstImg + pos + 8); 
00043377  #else 
00043380  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y), out[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y), out[1].hi); 
0004344b  #endif 
00043455  } }
0004345a __kernel void sr_conv_3x3_s1x1_n8_c1(__global unsigned char* srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(80 * sizeof(half)), int width, int height, int stride_in, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0) << 2); int y = get_global_id(1); DATA_TYPE8 output[4]; int pos; if (x < width && y < height) { output[0] = VLD8(9, weight_bias); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE8 weight[3]; DATA_TYPE8 in; uchar8 pix = (uchar8)(0); int pos_y = y + i - 1; if (pos_y<0 || pos_y>height - 1) continue; int pos = mad24(pos_y, stride_in, x); if (x > 0) pix.s0 = srcImg[pos - 1]; pix.s1234 = vload4(0, srcImg + pos); if (x + 4<width) pix.s5 = srcImg[pos + 4]; in = CONVERT8(pix); in *= (DATA_TYPE)(1.0f / 255.0f); weight[0] = VLD8(i * 3 + 0, weight_bias); weight[1] = VLD8(i * 3 + 1, weight_bias); weight[2] = VLD8(i * 3 + 2, weight_bias); output[0] = mad(weight[0], in.s0, output[0]); output[1] = mad(weight[0], in.s1, output[1]); output[2] = mad(weight[0], in.s2, output[2]); output[3] = mad(weight[0], in.s3, output[3]); output[0] = mad(weight[1], in.s1, output[0]); output[1] = mad(weight[1], in.s2, output[1]); output[2] = mad(weight[1], in.s3, output[2]); output[3] = mad(weight[1], in.s4, output[3]); output[0] = mad(weight[2], in.s2, output[0]); output[1] = mad(weight[2], in.s3, output[1]); output[2] = mad(weight[2], in.s4, output[2]); output[3] = mad(weight[2], in.s5, output[3]); } output[0] = fmax(output[0], (DATA_TYPE8)(0.0f)); output[1] = fmax(output[1], (DATA_TYPE8)(0.0f)); output[2] = fmax(output[2], (DATA_TYPE8)(0.0f)); output[3] = fmax(output[3], (DATA_TYPE8)(0.0f)); 
00043b55  #ifdef USE_BUFFER_OUT 
00043b6e  pos = mad24(y, stride_out, x << 3); vstore8(output[0], 0, dstImg + pos); vstore8(output[1], 1, dstImg + pos); vstore8(output[2], 2, dstImg + pos); vstore8(output[3], 3, dstImg + pos); 
00043c29  #else 
00043c32  WRITE_IMAGE(dstImg, (int2)(x * 2 + 0, y), output[0].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 1, y), output[0].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 2, y), output[1].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 3, y), output[1].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 4, y), output[2].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 5, y), output[2].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 6, y), output[3].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 7, y), output[3].hi); 
00043dfd  #endif 
00043e07  } }
00043e0e  #define SR_CONV_2x2_CORE(offset, out0, out1) \
00043e3e  w[0] = VLD2(offset + 0, weight_bias); \
00043e67  w[1] = VLD2(offset + 1, weight_bias); \
00043e90  w[2] = VLD2(offset + 2, weight_bias); \
00043eb9  out0 = mad((DATA_TYPE4)(in0[0].w, in0[1].x, in0[1].y, in0[1].z), w[0].x, out0); \
00043f0c  out1 = mad((DATA_TYPE4)(in0[1].w, in0[2].x, in0[2].y, in0[2].z), w[0].x, out1); \
00043f5f  out0 = mad(in0[1], w[1].x, out0); \
00043f84  out1 = mad(in0[2], w[1].x, out1); \
00043fa9  out0 = mad((DATA_TYPE4)(in0[1].y, in0[1].z, in0[1].w, in0[2].x), w[2].x, out0); \
00043ffc  out1 = mad((DATA_TYPE4)(in0[2].y, in0[2].z, in0[2].w, in0[3].x), w[2].x, out1); \
0004404f  out0 = mad((DATA_TYPE4)(in1.s0, in1.s1, in1.s1, in1.s2), w[0].y, out0); \
0004409a  out1 = mad((DATA_TYPE4)(in1.s2, in1.s3, in1.s3, in1.s4), w[0].y, out1); \
000440e5  out0 = mad((DATA_TYPE4)(in1.s1, in1.s1, in1.s2, in1.s2), w[1].y, out0); \
00044130  out1 = mad((DATA_TYPE4)(in1.s3, in1.s3, in1.s4, in1.s4), w[1].y, out1); \
0004417b  out0 = mad((DATA_TYPE4)(in1.s1, in1.s2, in1.s2, in1.s3), w[2].y, out0); \
000441c6  out1 = mad((DATA_TYPE4)(in1.s3, in1.s4, in1.s4, in1.s5), w[2].y, out1); \
00044214  __kernel void sr_conv_2x2_s1x1_n1_c2(__read_only image2d_t srcImg0, __global unsigned char* srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(19 * sizeof(half)), int width, int height, int stride_in_1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE8 out[2]; DATA_TYPE2 w[3]; DATA_TYPE4 in0[4]; DATA_TYPE8 in1; uchar8 pix; int pos; int width_in_1 = (width >> 1); int height_in_1 = (height >> 1); int x1, y1; if (x * 4 < width && y < height) { DATA_TYPE bias = VLD(18, weight_bias); out[0] = (DATA_TYPE8)(bias); out[1] = out[0]; x1 = (x << 1); int pos_y = y - 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); pix = (uchar8)(0); y1 = (pos_y >> 1); if (y1 >= 0) { pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); if (x1 + 4<width_in_1) pix.s5 = srcImg1[pos + 4]; } in1 = CONVERT8(pix); in1 *= (DATA_TYPE)(1.0f / 255.0f); SR_CONV_2x2_CORE(0, out[0].lo, out[0].hi); pos_y = y + 0; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); pix = (uchar8)(0); y1 = (pos_y >> 1); pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); if (x1 + 4<width_in_1) pix.s5 = srcImg1[pos + 4]; in1 = CONVERT8(pix); in1 *= (DATA_TYPE)(1.0f / 255.0f); SR_CONV_2x2_CORE(3, out[0].lo, out[0].hi); SR_CONV_2x2_CORE(0, out[1].lo, out[1].hi); pos_y = y + 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); SR_CONV_2x2_CORE(6, out[0].lo, out[0].hi); SR_CONV_2x2_CORE(3, out[1].lo, out[1].hi); pos_y = y + 2; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); pix = (uchar8)(0); y1 = (pos_y >> 1); if (y1 < height_in_1) { pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); if (x1 + 4<width_in_1) pix.s5 = srcImg1[pos + 4]; } in1 = CONVERT8(pix); in1 *= (DATA_TYPE)(1.0f / 255.0f); SR_CONV_2x2_CORE(6, out[1].lo, out[1].hi); out[0] = mad(out[0], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out[1] = mad(out[1], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); pos = mad24(y, stride_out, x * 4); vstore8(convert_uchar8_sat(out[0]), 0, dstImg + pos); vstore8(convert_uchar8_sat(out[1]), 0, dstImg + pos + stride_out); } }
00044e46  #define SR_CONV_2x2_CORE_LINEAR(offset, out0, out1) \
00044e7d  w[0] = VLD2(offset + 0, weight_bias); \
00044ea6  w[1] = VLD2(offset + 1, weight_bias); \
00044ecf  w[2] = VLD2(offset + 2, weight_bias); \
00044ef8  out0 = mad((DATA_TYPE4)(in0[0].w, in0[1].x, in0[1].y, in0[1].z), w[0].x, out0); \
00044f4b  out1 = mad((DATA_TYPE4)(in0[1].w, in0[2].x, in0[2].y, in0[2].z), w[0].x, out1); \
00044f9e  out0 = mad(in0[1], w[1].x, out0); \
00044fc3  out1 = mad(in0[2], w[1].x, out1); \
00044fe8  out0 = mad((DATA_TYPE4)(in0[1].y, in0[1].z, in0[1].w, in0[2].x), w[2].x, out0); \
0004503b  out1 = mad((DATA_TYPE4)(in0[2].y, in0[2].z, in0[2].w, in0[3].x), w[2].x, out1); \
0004508e  out0 = mad((DATA_TYPE4)(in1.s8, in1.s1, in1.s9, in1.s2), w[0].y, out0); \
000450d9  out1 = mad((DATA_TYPE4)(in1.sa, in1.s3, in1.sb, in1.s4), w[0].y, out1); \
00045124  out0 = mad((DATA_TYPE4)(in1.s1, in1.s9, in1.s2, in1.sa), w[1].y, out0); \
0004516f  out1 = mad((DATA_TYPE4)(in1.s3, in1.sb, in1.s4, in1.sc), w[1].y, out1); \
000451ba  out0 = mad((DATA_TYPE4)(in1.s9, in1.s2, in1.sa, in1.s3), w[2].y, out0); \
00045205  out1 = mad((DATA_TYPE4)(in1.sb, in1.s4, in1.sc, in1.s5), w[2].y, out1); \
00045253  __kernel void sr_conv_2x2_s1x1_n1_c2(__read_only image2d_t srcImg0, __global unsigned char* srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(19 * sizeof(half)), int width, int height, int stride_in_1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE8 out[2]; DATA_TYPE2 w[3]; DATA_TYPE4 in0[4]; DATA_TYPE16 inA, inB, in1; uchar8 pix; int pos; int width_in_1 = (width >> 1); int height_in_1 = (height >> 1); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { DATA_TYPE bias = VLD(18, weight_bias); out[0] = (DATA_TYPE8)(bias); out[1] = out[0]; x1 = (x << 1); pix = (uchar8)(0); y1 = (y >> 1); pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); pix.s5 = pix.s4; if (x1 + 4 < width_in_1) pix.s5 = srcImg1[pos + 4]; inB.lo = CONVERT8(pix); inB.hi = (inB.s12345678 + inB.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inB.s5 = 0.0f; inB *= (DATA_TYPE)(1.0f / 255.0f); if (y>0) { pix = (uchar8)(0); y1 = ((y - 1) >> 1); pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); pix.s5 = pix.s4; if (x1 + 4 < width_in_1) pix.s5 = srcImg1[pos + 4]; inA.lo = CONVERT8(pix); inA.hi = (inA.s12345678 + inA.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inA.s5 = 0.0f; inA *= (DATA_TYPE)(1.0f / 255.0f); pos_y = y - 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = (inA + inB)*(DATA_TYPE)(0.5f); SR_CONV_2x2_CORE_LINEAR(0, out[0].lo, out[0].hi); } pos_y = y + 0; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = inB; SR_CONV_2x2_CORE_LINEAR(3, out[0].lo, out[0].hi); SR_CONV_2x2_CORE_LINEAR(0, out[1].lo, out[1].hi); pos_y = y + 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); inA = inB; y1 = ((y+2) >> 1); if (y1 < height_in_1) { pix = (uchar8)(0); pos = mad24(y1, stride_in_1, x1); if (x1 > 0) pix.s0 = srcImg1[pos - 1]; pix.s1234 = vload4(0, srcImg1 + pos); pix.s5 = pix.s4; if (x1 + 4 < width_in_1) pix.s5 = srcImg1[pos + 4]; inA.lo = CONVERT8(pix); inA.hi = (inA.s12345678 + inA.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inA.s5 = 0.0f; inA *= (DATA_TYPE)(1.0f / 255.0f); } in1 = (inA + inB)*(DATA_TYPE)(0.5f); SR_CONV_2x2_CORE_LINEAR(6, out[0].lo, out[0].hi); SR_CONV_2x2_CORE_LINEAR(3, out[1].lo, out[1].hi); if (y + 1 < height - 1) { pos_y = y + 2; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = inA; SR_CONV_2x2_CORE_LINEAR(6, out[1].lo, out[1].hi); } out[0] = mad(out[0], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out[1] = mad(out[1], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); pos = mad24(y, stride_out, x * 4); vstore8(convert_uchar8_sat(out[0]), 0, dstImg + pos); vstore8(convert_uchar8_sat(out[1]), 0, dstImg + pos + stride_out); } }
000460c4 __kernel void sr_conv_3x3_s1x1_n1_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(40 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1); DATA_TYPE4 output[4]; if (x < width && y < height) { output[0] = (DATA_TYPE4)(0.0f); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE4 input[6]; DATA_TYPE4 w[3]; int pos_y = y + i - 1; input[0] = READ_IMAGE(srcImg, sampler, (int2)(x - 1, pos_y)); input[1] = READ_IMAGE(srcImg, sampler, (int2)(x + 0, pos_y)); input[2] = READ_IMAGE(srcImg, sampler, (int2)(x + 1, pos_y)); input[3] = READ_IMAGE(srcImg, sampler, (int2)(x + 2, pos_y)); input[4] = READ_IMAGE(srcImg, sampler, (int2)(x + 3, pos_y)); input[5] = READ_IMAGE(srcImg, sampler, (int2)(x + 4, pos_y)); w[0] = VLD4(i * 3 + 0, weight_bias); w[1] = VLD4(i * 3 + 1, weight_bias); w[2] = VLD4(i * 3 + 2, weight_bias); output[0] = mad(w[0], input[0], output[0]); output[1] = mad(w[0], input[1], output[1]); output[2] = mad(w[0], input[2], output[2]); output[3] = mad(w[0], input[3], output[3]); output[0] = mad(w[1], input[1], output[0]); output[1] = mad(w[1], input[2], output[1]); output[2] = mad(w[1], input[3], output[2]); output[3] = mad(w[1], input[4], output[3]); output[0] = mad(w[2], input[2], output[0]); output[1] = mad(w[2], input[3], output[1]); output[2] = mad(w[2], input[4], output[2]); output[3] = mad(w[2], input[5], output[3]); } output[0].x = dot((DATA_TYPE4)(1.0f), output[0]); output[0].y = dot((DATA_TYPE4)(1.0f), output[1]); output[0].z = dot((DATA_TYPE4)(1.0f), output[2]); output[0].w = dot((DATA_TYPE4)(1.0f), output[3]); output[0] += VLD4(9, weight_bias); 
000467fb  #ifdef USE_BUFFER_OUT 
00046814  int pos = mad24(y, stride, x); vstore4(output[0], 0, dstImg + pos); 
0004685b  #else 
00046864  WRITE_IMAGE(dstImg, (int2)(x / 4, y), output[0]); 
00046899  #endif 
000468a3  } }
000468aa  #define DCONV_CORE(w, offset, inA, inB, outA, outB) \
000468e1  w = VLD8(offset + 0, weight_bias); \
00046907  outA = mad(w.lo, inA.x, outA); \
00046929  outB = mad(w.lo, inB.x, outB); \
0004694b  outA = mad(w.hi, inA.y, outA); \
0004696d  outB = mad(w.hi, inB.y, outB); \
0004698f  w = VLD8(offset + 1, weight_bias); \
000469b5  outA = mad(w.lo, inA.z, outA); \
000469d7  outB = mad(w.lo, inB.z, outB); \
000469f9  outA = mad(w.hi, inA.w, outA); \
00046a1b  outB = mad(w.hi, inB.w, outB); \
00046a40  __kernel void sr_deconv_4x4_s2x2_n4_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(260 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0)*4; int y = get_global_id(1); DATA_TYPE8 out[2]; DATA_TYPE8 w; DATA_TYPE4 in[4]; if (x < width && y < height) { out[0].lo = VLD4(64, weight_bias); out[0].hi = out[0].lo; out[1] = out[0]; int i_start = (y & 1); int offset = i_start * 8; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in[0] = READ_IMAGE(srcImg, sampler, (int2)((x - 2) >> 1, pos_y)); in[1] = READ_IMAGE(srcImg, sampler, (int2)((x + 0) >> 1, pos_y)); in[2] = READ_IMAGE(srcImg, sampler, (int2)((x + 2) >> 1, pos_y)); in[3] = READ_IMAGE(srcImg, sampler, (int2)((x + 4) >> 1, pos_y)); DCONV_CORE(w, offset + 0, in[0], in[1], out[0].lo, out[1].lo); DCONV_CORE(w, offset + 2, in[1], in[2], out[0].hi, out[1].hi); DCONV_CORE(w, offset + 4, in[1], in[2], out[0].lo, out[1].lo); DCONV_CORE(w, offset + 6, in[2], in[3], out[0].hi, out[1].hi); offset += 16; } 
00046ed1  #ifdef USE_BUFFER_OUT 
00046eea  int pos = mad24(y, stride, x << 2); vstore8(out[0], 0, dstImg + pos); vstore8(out[1], 0, dstImg + pos + 8); 
00046f59  #else 
00046f62  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y), out[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y), out[1].hi); 
0004702d  #endif 
00047037  } } 
00047041  #define SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias) \
0004708d  w = VLD8(offset + 0, weight_bias); \
000470b3  out0 = mad(w, in0.s0, out0); \
000470d3  out1 = mad(w, in1.s0, out1); \
000470f3  w = VLD8(offset + 1, weight_bias); \
00047119  out0 = mad(w, in0.s1, out0); \
00047139  out1 = mad(w, in1.s1, out1); \
00047159  w = VLD8(offset + 2, weight_bias); \
0004717f  out0 = mad(w, in0.s2, out0); \
0004719f  out1 = mad(w, in1.s2, out1); \
000471bf  w = VLD8(offset + 3, weight_bias); \
000471e5  out0 = mad(w, in0.s3, out0); \
00047205  out1 = mad(w, in1.s3, out1); \
00047225  w = VLD8(offset + 4, weight_bias); \
0004724b  out0 = mad(w, in0.s4, out0); \
0004726b  out1 = mad(w, in1.s4, out1); \
0004728b  w = VLD8(offset + 5, weight_bias); \
000472b1  out0 = mad(w, in0.s5, out0); \
000472d1  out1 = mad(w, in1.s5, out1); \
000472f1  w = VLD8(offset + 6, weight_bias); \
00047317  out0 = mad(w, in0.s6, out0); \
00047337  out1 = mad(w, in1.s6, out1); \
00047357  w = VLD8(offset + 7, weight_bias); \
0004737d  out0 = mad(w, in0.s7, out0); \
0004739d  out1 = mad(w, in1.s7, out1); \
000473c3  #define SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, offset, weight_bias) \
0004740f  w = VLD8(offset + 0, weight_bias); \
00047435  out0.lo = mad(w.lo, in0.s0, out0.lo); \
0004745e  out1.lo = mad(w.lo, in1.s0, out1.lo); \
00047487  out0.hi = mad(w.hi, in0.s4, out0.hi); \
000474b0  out1.hi = mad(w.hi, in1.s4, out1.hi); \
000474d9  w = VLD8(offset + 1, weight_bias); \
000474ff  out0.lo = mad(w.lo, in0.s1, out0.lo); \
00047528  out1.lo = mad(w.lo, in1.s1, out1.lo); \
00047551  out0.hi = mad(w.hi, in0.s5, out0.hi); \
0004757a  out1.hi = mad(w.hi, in1.s5, out1.hi); \
000475a3  w = VLD8(offset + 2, weight_bias); \
000475c9  out0.lo = mad(w.lo, in0.s2, out0.lo); \
000475f2  out1.lo = mad(w.lo, in1.s2, out1.lo); \
0004761b  out0.hi = mad(w.hi, in0.s6, out0.hi); \
00047644  out1.hi = mad(w.hi, in1.s6, out1.hi); \
0004766d  w = VLD8(offset + 3, weight_bias); \
00047693  out0.lo = mad(w.lo, in0.s3, out0.lo); \
000476bc  out1.lo = mad(w.lo, in1.s3, out1.lo); \
000476e5  out0.hi = mad(w.hi, in0.s7, out0.hi); \
0004770e  out1.hi = mad(w.hi, in1.s7, out1.hi); \
0004773a  __kernel void sr_conv_3x3_s1x1_n8_c8_conv_1x1_s1x1_n8_c8(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias_3x3 __ATTRIBUTE_MAX_CONSANT_SIZE_(585 * sizeof(half)), __constant half *weight_bias_1x1 __ATTRIBUTE_MAX_CONSANT_SIZE_(108 * sizeof(half)), int width, int height, int stride, int merge1x1) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1); int i, j; DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1; DATA_TYPE8 w; if (x < width && y < height) { 
0004797b  #ifdef GROUP_CONV 
00047990  out0 = VLD8(36, weight_bias_3x3); 
000479b5  #else 
000479be  out0 = VLD8(72, weight_bias_3x3); 
000479e3  #endif 
000479ed  out1 = out0; short offset = 0; for (i = 0; i < 3; i++) { int pos_y = y + i - 1; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y)); for (j = 0; j < 3; j++) { in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, pos_y)); pos_x += 2; 
00047b82  #ifdef GROUP_CONV 
00047b97  SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, offset, weight_bias_3x3); offset += 4; 
00047bed  #else 
00047bf6  SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias_3x3); offset += 8; 
00047c4c  #endif 
00047c56  in0 = in1; } } in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); out0 = VLD8(8, weight_bias_1x1); out1 = out0; SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, 0, weight_bias_1x1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 0, y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 1, y)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 2, y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 3, y)); 
00047e13  #ifdef GROUP_CONV 
00047e28  DATA_TYPE q = VLD(0, weight_bias_3x3 + 296); 
00047e58  #else 
00047e61  DATA_TYPE q = VLD(0, weight_bias_3x3 + 584); 
00047e91  #endif 
00047e9b  out0 = mad(in0, q, out0); out1 = mad(in1, q, out1); if (merge1x1) { in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); out0.lo = VLD4(8, weight_bias_1x1 + 72); out0.hi = out0.lo; w = VLD8(0, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s0, out0.lo); out0.hi = mad(w.lo, in1.s0, out0.hi); out0.lo = mad(w.hi, in0.s1, out0.lo); out0.hi = mad(w.hi, in1.s1, out0.hi); w = VLD8(1, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s2, out0.lo); out0.hi = mad(w.lo, in1.s2, out0.hi); out0.lo = mad(w.hi, in0.s3, out0.lo); out0.hi = mad(w.hi, in1.s3, out0.hi); w = VLD8(2, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s4, out0.lo); out0.hi = mad(w.lo, in1.s4, out0.hi); out0.lo = mad(w.hi, in0.s5, out0.lo); out0.hi = mad(w.hi, in1.s5, out0.hi); w = VLD8(3, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s6, out0.lo); out0.hi = mad(w.lo, in1.s6, out0.hi); out0.lo = mad(w.hi, in0.s7, out0.lo); out0.hi = mad(w.hi, in1.s7, out0.hi); 
00048256  #ifdef USE_BUFFER_OUT 
0004826f  int pos = mad24(y, stride, x << 2); vstore8(out0, 0, dstImg + pos + 0); 
000482ba  #else 
000482c3  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out0.hi); 
00048326  #endif 
00048330  } else { out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); 
0004838a  #ifdef USE_BUFFER_OUT 
000483a3  int pos = mad24(y, stride, x << 3); vstore8(out0, 0, dstImg + pos); vstore8(out1, 1, dstImg + pos); 
0004840a  #else 
00048413  WRITE_IMAGE(dstImg, (int2)(2 * x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(2 * x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 3, y), out1.hi); 
000484e6  #endif 
000484f0  } } }
000484f9  #pragma OPENCL EXTENSION cl_khr_subgroups : enable 
00048532  #define SR_CONV_3x3_CORE_A(we) \
00048554  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 0)), as_half2(sub_group_broadcast(we.s1, 0)), as_half2(sub_group_broadcast(we.s2, 0)), as_half2(sub_group_broadcast(we.s3, 0))); \
0004860d  out[0] = mad(w, in[0].s0, out[0]); \
00048633  out[1] = mad(w, in[1].s0, out[1]); \
00048659  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 1)), as_half2(sub_group_broadcast(we.s1, 1)), as_half2(sub_group_broadcast(we.s2, 1)), as_half2(sub_group_broadcast(we.s3, 1))); \
00048712  out[0] = mad(w, in[0].s1, out[0]); \
00048738  out[1] = mad(w, in[1].s1, out[1]); \
0004875e  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 2)), as_half2(sub_group_broadcast(we.s1, 2)), as_half2(sub_group_broadcast(we.s2, 2)), as_half2(sub_group_broadcast(we.s3, 2))); \
00048817  out[0] = mad(w, in[0].s2, out[0]); \
0004883d  out[1] = mad(w, in[1].s2, out[1]); \
00048863  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 3)), as_half2(sub_group_broadcast(we.s1, 3)), as_half2(sub_group_broadcast(we.s2, 3)), as_half2(sub_group_broadcast(we.s3, 3))); \
0004891c  out[0] = mad(w, in[0].s3, out[0]); \
00048942  out[1] = mad(w, in[1].s3, out[1]); \
00048968  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 4)), as_half2(sub_group_broadcast(we.s1, 4)), as_half2(sub_group_broadcast(we.s2, 4)), as_half2(sub_group_broadcast(we.s3, 4))); \
00048a21  out[0] = mad(w, in[0].s4, out[0]); \
00048a47  out[1] = mad(w, in[1].s4, out[1]); \
00048a6d  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 5)), as_half2(sub_group_broadcast(we.s1, 5)), as_half2(sub_group_broadcast(we.s2, 5)), as_half2(sub_group_broadcast(we.s3, 5))); \
00048b26  out[0] = mad(w, in[0].s5, out[0]); \
00048b4c  out[1] = mad(w, in[1].s5, out[1]); \
00048b72  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 6)), as_half2(sub_group_broadcast(we.s1, 6)), as_half2(sub_group_broadcast(we.s2, 6)), as_half2(sub_group_broadcast(we.s3, 6))); \
00048c2b  out[0] = mad(w, in[0].s6, out[0]); \
00048c51  out[1] = mad(w, in[1].s6, out[1]); \
00048c77  w = (DATA_TYPE8)(as_half2(sub_group_broadcast(we.s0, 7)), as_half2(sub_group_broadcast(we.s1, 7)), as_half2(sub_group_broadcast(we.s2, 7)), as_half2(sub_group_broadcast(we.s3, 7))); \
00048d30  out[0] = mad(w, in[0].s7, out[0]); \
00048d56  out[1] = mad(w, in[1].s7, out[1]); \
00048d7f  #pragma OPENCL EXTENSION cl_khr_subgroups : enable 
00048db8  #define SR_CONV_3x3_CORE_B(we, in0, in1) \
00048de4  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 0)), in0.s0, out0.s01); \
00048e32  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 0)), in1.s0, out1.s01); \
00048e80  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 0)), in0.s0, out0.s23); \
00048ece  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 0)), in1.s0, out1.s23); \
00048f1c  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 0)), in0.s0, out0.s45); \
00048f6a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 0)), in1.s0, out1.s45); \
00048fb8  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 0)), in0.s0, out0.s67); \
00049006  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 0)), in1.s0, out1.s67); \
00049054  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 1)), in0.s1, out0.s01); \
000490a2  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 1)), in1.s1, out1.s01); \
000490f0  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 1)), in0.s1, out0.s23); \
0004913e  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 1)), in1.s1, out1.s23); \
0004918c  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 1)), in0.s1, out0.s45); \
000491da  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 1)), in1.s1, out1.s45); \
00049228  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 1)), in0.s1, out0.s67); \
00049276  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 1)), in1.s1, out1.s67); \
000492c4  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 2)), in0.s2, out0.s01); \
00049312  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 2)), in1.s2, out1.s01); \
00049360  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 2)), in0.s2, out0.s23); \
000493ae  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 2)), in1.s2, out1.s23); \
000493fc  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 2)), in0.s2, out0.s45); \
0004944a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 2)), in1.s2, out1.s45); \
00049498  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 2)), in0.s2, out0.s67); \
000494e6  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 2)), in1.s2, out1.s67); \
00049534  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 3)), in0.s3, out0.s01); \
00049582  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 3)), in1.s3, out1.s01); \
000495d0  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 3)), in0.s3, out0.s23); \
0004961e  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 3)), in1.s3, out1.s23); \
0004966c  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 3)), in0.s3, out0.s45); \
000496ba  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 3)), in1.s3, out1.s45); \
00049708  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 3)), in0.s3, out0.s67); \
00049756  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 3)), in1.s3, out1.s67); \
000497a4  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 4)), in0.s4, out0.s01); \
000497f2  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 4)), in1.s4, out1.s01); \
00049840  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 4)), in0.s4, out0.s23); \
0004988e  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 4)), in1.s4, out1.s23); \
000498dc  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 4)), in0.s4, out0.s45); \
0004992a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 4)), in1.s4, out1.s45); \
00049978  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 4)), in0.s4, out0.s67); \
000499c6  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 4)), in1.s4, out1.s67); \
00049a14  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 5)), in0.s5, out0.s01); \
00049a62  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 5)), in1.s5, out1.s01); \
00049ab0  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 5)), in0.s5, out0.s23); \
00049afe  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 5)), in1.s5, out1.s23); \
00049b4c  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 5)), in0.s5, out0.s45); \
00049b9a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 5)), in1.s5, out1.s45); \
00049be8  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 5)), in0.s5, out0.s67); \
00049c36  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 5)), in1.s5, out1.s67); \
00049c84  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 6)), in0.s6, out0.s01); \
00049cd2  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 6)), in1.s6, out1.s01); \
00049d20  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 6)), in0.s6, out0.s23); \
00049d6e  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 6)), in1.s6, out1.s23); \
00049dbc  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 6)), in0.s6, out0.s45); \
00049e0a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 6)), in1.s6, out1.s45); \
00049e58  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 6)), in0.s6, out0.s67); \
00049ea6  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 6)), in1.s6, out1.s67); \
00049ef4  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 7)), in0.s7, out0.s01); \
00049f42  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 7)), in1.s7, out1.s01); \
00049f90  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 7)), in0.s7, out0.s23); \
00049fde  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 7)), in1.s7, out1.s23); \
0004a02c  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 7)), in0.s7, out0.s45); \
0004a07a  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 7)), in1.s7, out1.s45); \
0004a0c8  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 7)), in0.s7, out0.s67); \
0004a116  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 7)), in1.s7, out1.s67); \
0004a16a  #pragma OPENCL EXTENSION cl_khr_subgroups : enable 
0004a1a3  #define SR_CONV_3x3_CORE_G(we, in0, in1) \
0004a1cf  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 0)), in0.s0, out0.s01); \
0004a21d  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 0)), in1.s0, out1.s01); \
0004a26b  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 0)), in0.s0, out0.s23); \
0004a2b9  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 0)), in1.s0, out1.s23); \
0004a307  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 0)), in0.s4, out0.s45); \
0004a355  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 0)), in1.s4, out1.s45); \
0004a3a3  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 0)), in0.s4, out0.s67); \
0004a3f1  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 0)), in1.s4, out1.s67); \
0004a43f  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 1)), in0.s1, out0.s01); \
0004a48d  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 1)), in1.s1, out1.s01); \
0004a4db  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 1)), in0.s1, out0.s23); \
0004a529  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 1)), in1.s1, out1.s23); \
0004a577  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 1)), in0.s5, out0.s45); \
0004a5c5  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 1)), in1.s5, out1.s45); \
0004a613  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 1)), in0.s5, out0.s67); \
0004a661  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 1)), in1.s5, out1.s67); \
0004a6af  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 2)), in0.s2, out0.s01); \
0004a6fd  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 2)), in1.s2, out1.s01); \
0004a74b  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 2)), in0.s2, out0.s23); \
0004a799  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 2)), in1.s2, out1.s23); \
0004a7e7  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 2)), in0.s6, out0.s45); \
0004a835  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 2)), in1.s6, out1.s45); \
0004a883  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 2)), in0.s6, out0.s67); \
0004a8d1  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 2)), in1.s6, out1.s67); \
0004a91f  out0.s01 = mad(as_half2(sub_group_broadcast(we.s0, 3)), in0.s3, out0.s01); \
0004a96d  out1.s01 = mad(as_half2(sub_group_broadcast(we.s0, 3)), in1.s3, out1.s01); \
0004a9bb  out0.s23 = mad(as_half2(sub_group_broadcast(we.s1, 3)), in0.s3, out0.s23); \
0004aa09  out1.s23 = mad(as_half2(sub_group_broadcast(we.s1, 3)), in1.s3, out1.s23); \
0004aa57  out0.s45 = mad(as_half2(sub_group_broadcast(we.s2, 3)), in0.s7, out0.s45); \
0004aaa5  out1.s45 = mad(as_half2(sub_group_broadcast(we.s2, 3)), in1.s7, out1.s45); \
0004aaf3  out0.s67 = mad(as_half2(sub_group_broadcast(we.s3, 3)), in0.s7, out0.s67); \
0004ab41  out1.s67 = mad(as_half2(sub_group_broadcast(we.s3, 3)), in1.s7, out1.s67); \
0004ab93 __kernel void sr_conv_3x3_s1x1_n8_c8_prelu(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias_slope __ATTRIBUTE_MAX_CONSANT_SIZE_(592 * sizeof(half)), int width, int height, int stride, int idx) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1); uint local_id = get_sub_group_local_id(); int i, j; DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1, in2, in3; DATA_TYPE8 w; float4 we; if (x < width && y < height) { out0 = VLD8(72, weight_bias_slope); out1 = out0; short offset = 0; for (i = 0; i < 3; i++) { int pos_y = y + i - 1; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y)); for (j = 0; j < 3; j++) { in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, pos_y)); pos_x += 2; we = VLD4(offset + local_id, (__constant float *)weight_bias_slope); SR_CONV_3x3_CORE_B(we, in0, in1); offset += 8; in0 = in1; } } w = VLD8(73, weight_bias_slope); out0 = fmax(out0, (DATA_TYPE8)(0.0f)) + w * fmin(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)) + w * fmin(out1, (DATA_TYPE8)(0.0f)); 
0004b09f  #ifdef USE_BUFFER_OUT 
0004b0b8  int pos = mad24(y, stride, x << 3); vstore8(out0, 0, dstImg + pos); vstore8(out1, 1, dstImg + pos); 
0004b11f  #else 
0004b128  WRITE_IMAGE(dstImg, (int2)(2 * x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(2 * x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 3, y), out1.hi); 
0004b1fb  #endif 
0004b205  } }
0004b20c  #pragma OPENCL EXTENSION cl_khr_subgroups : enable 
0004b242  __kernel void sr_conv_3x3_s1x1_n8_c1(__global unsigned char* srcImg, OUT_TYPE dstImg, __constant half *weight_bias, __constant half *weight_bias_1x1, int width, int height, int stride_in, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0) << 2); int y = get_global_id(1); DATA_TYPE8 output[4]; DATA_TYPE8 w; DATA_TYPE8 in, in1, in2, in3; int pos; if (x < width && y < height) { output[0] = VLD8(9, weight_bias); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE8 weight[3]; uchar8 pix = (uchar8)(0); int pos_y = y + i - 1; if (pos_y<0 || pos_y>height - 1) continue; int pos = mad24(pos_y, stride_in, x); if (x > 0) pix.s0 = srcImg[pos - 1]; pix.s1234 = vload4(0, srcImg + pos); if (x + 4 < width) pix.s5 = srcImg[pos + 4]; in = convert_half8(pix); in *= (DATA_TYPE)(1.0f / 255.0f); weight[0] = VLD8(i * 3 + 0, weight_bias); weight[1] = VLD8(i * 3 + 1, weight_bias); weight[2] = VLD8(i * 3 + 2, weight_bias); output[0] = mad(weight[0], in.s0, output[0]); output[1] = mad(weight[0], in.s1, output[1]); output[2] = mad(weight[0], in.s2, output[2]); output[3] = mad(weight[0], in.s3, output[3]); output[0] = mad(weight[1], in.s1, output[0]); output[1] = mad(weight[1], in.s2, output[1]); output[2] = mad(weight[1], in.s3, output[2]); output[3] = mad(weight[1], in.s4, output[3]); output[0] = mad(weight[2], in.s2, output[0]); output[1] = mad(weight[2], in.s3, output[1]); output[2] = mad(weight[2], in.s4, output[2]); output[3] = mad(weight[2], in.s5, output[3]); } in = fmax(output[0], (DATA_TYPE8)(0.0f)); in1 = fmax(output[1], (DATA_TYPE8)(0.0f)); in2 = fmax(output[2], (DATA_TYPE8)(0.0f)); in3 = fmax(output[3], (DATA_TYPE8)(0.0f)); output[0].lo = VLD4(8, weight_bias_1x1); output[0].hi = output[0].lo; output[1] = output[0]; w = VLD8(0, weight_bias_1x1); output[0].lo = mad(w.lo, in.s0, output[0].lo); output[0].hi = mad(w.lo, in1.s0, output[0].hi); output[1].lo = mad(w.lo, in2.s0, output[1].lo); output[1].hi = mad(w.lo, in3.s0, output[1].hi); output[0].lo = mad(w.hi, in.s1, output[0].lo); output[0].hi = mad(w.hi, in1.s1, output[0].hi); output[1].lo = mad(w.hi, in2.s1, output[1].lo); output[1].hi = mad(w.hi, in3.s1, output[1].hi); w = VLD8(1, weight_bias_1x1); output[0].lo = mad(w.lo, in.s2, output[0].lo); output[0].hi = mad(w.lo, in1.s2, output[0].hi); output[1].lo = mad(w.lo, in2.s2, output[1].lo); output[1].hi = mad(w.lo, in3.s2, output[1].hi); output[0].lo = mad(w.hi, in.s3, output[0].lo); output[0].hi = mad(w.hi, in1.s3, output[0].hi); output[1].lo = mad(w.hi, in2.s3, output[1].lo); output[1].hi = mad(w.hi, in3.s3, output[1].hi); w = VLD8(2, weight_bias_1x1); output[0].lo = mad(w.lo, in.s4, output[0].lo); output[0].hi = mad(w.lo, in1.s4, output[0].hi); output[1].lo = mad(w.lo, in2.s4, output[1].lo); output[1].hi = mad(w.lo, in3.s4, output[1].hi); output[0].lo = mad(w.hi, in.s5, output[0].lo); output[0].hi = mad(w.hi, in1.s5, output[0].hi); output[1].lo = mad(w.hi, in2.s5, output[1].lo); output[1].hi = mad(w.hi, in3.s5, output[1].hi); w = VLD8(3, weight_bias_1x1); output[0].lo = mad(w.lo, in.s6, output[0].lo); output[0].hi = mad(w.lo, in1.s6, output[0].hi); output[1].lo = mad(w.lo, in2.s6, output[1].lo); output[1].hi = mad(w.lo, in3.s6, output[1].hi); output[0].lo = mad(w.hi, in.s7, output[0].lo); output[0].hi = mad(w.hi, in1.s7, output[0].hi); output[1].lo = mad(w.hi, in2.s7, output[1].lo); output[1].hi = mad(w.hi, in3.s7, output[1].hi); 
0004c007  #ifdef USE_BUFFER_OUT 
0004c020  pos = mad24(y, stride_out, x << 2); 
0004c047  #if QUANT 
0004c054  vstore8(convert_uchar8_sat_rte(output[0]), 0, (__global unsigned char*)dstImg + pos); vstore8(convert_uchar8_sat_rte(output[1]), 1, (__global unsigned char*)dstImg + pos); 
0004c103  #else 
0004c10c  vstore8(output[0], 0, dstImg + pos); vstore8(output[1], 1, dstImg + pos); 
0004c159  #endif 
0004c166  #else 
0004c16f  WRITE_IMAGE(dstImg, (int2)(x + 0, y), output[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), output[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y), output[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y), output[1].hi); 
0004c246  #endif 
0004c250  } } 
0004c25a  #pragma OPENCL EXTENSION cl_khr_subgroups : enable 
0004c290  __kernel void sr_conv_3x3_s1x1_n8_c1(__global unsigned char* srcImg, OUT_TYPE dstImg, __constant half *weight_bias, int width, int height, int stride_in, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0)<<2); int y = get_global_id(1); DATA_TYPE8 output[4]; int pos; if (x < width && y < height) { output[0] = VLD8(9, weight_bias); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE8 weight[3]; DATA_TYPE8 in; uchar8 pix = (uchar8)(0); int pos_y = y + i - 1; if (pos_y<0 || pos_y>height - 1) continue; int pos = mad24(pos_y, stride_in, x); if (x > 0) pix.s0 = srcImg[pos - 1]; pix.s1234 = vload4(0, srcImg + pos); if(x+4<width) pix.s5 = srcImg[pos + 4]; in = convert_half8(pix); in *= (DATA_TYPE)(1.0f / 255.0f); weight[0] = VLD8(i * 3 + 0, weight_bias); weight[1] = VLD8(i * 3 + 1, weight_bias); weight[2] = VLD8(i * 3 + 2, weight_bias); output[0] = mad(weight[0], in.s0, output[0]); output[1] = mad(weight[0], in.s1, output[1]); output[2] = mad(weight[0], in.s2, output[2]); output[3] = mad(weight[0], in.s3, output[3]); output[0] = mad(weight[1], in.s1, output[0]); output[1] = mad(weight[1], in.s2, output[1]); output[2] = mad(weight[1], in.s3, output[2]); output[3] = mad(weight[1], in.s4, output[3]); output[0] = mad(weight[2], in.s2, output[0]); output[1] = mad(weight[2], in.s3, output[1]); output[2] = mad(weight[2], in.s4, output[2]); output[3] = mad(weight[2], in.s5, output[3]); } output[0] = fmax(output[0], (DATA_TYPE8)(0.0f)); output[1] = fmax(output[1], (DATA_TYPE8)(0.0f)); output[2] = fmax(output[2], (DATA_TYPE8)(0.0f)); output[3] = fmax(output[3], (DATA_TYPE8)(0.0f)); 
0004c95b  #ifdef USE_BUFFER_OUT 
0004c974  pos = mad24(y, stride_out, x << 3); 
0004c99b  #if QUANT 
0004c9a8  vstore8(convert_uchar8_sat_rte(output[0]), 0, (__global unsigned char*)dstImg + pos); vstore8(convert_uchar8_sat_rte(output[1]), 1, (__global unsigned char*)dstImg + pos); vstore8(convert_uchar8_sat_rte(output[2]), 2, (__global unsigned char*)dstImg + pos); vstore8(convert_uchar8_sat_rte(output[3]), 3, (__global unsigned char*)dstImg + pos); 
0004cb03  #else 
0004cb0c  vstore8(output[0], 0, dstImg + pos); vstore8(output[1], 1, dstImg + pos); vstore8(output[2], 2, dstImg + pos); vstore8(output[3], 3, dstImg + pos); 
0004cba3  #endif 
0004cbb0  #else 
0004cbb9  WRITE_IMAGE(dstImg, (int2)(x * 2 + 0, y), output[0].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 1, y), output[0].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 2, y), output[1].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 3, y), output[1].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 4, y), output[2].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 5, y), output[2].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 6, y), output[3].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 7, y), output[3].hi); 
0004cd84  #endif 
0004cd8e  } } 
0004cd96 __kernel void sr_conv_3x3_s1x1_n1_c4(__read_only image2d_t srcImg, __global DATA_TYPE *dstImg, __constant half *weight_bias, int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE4 output[4]; DATA_TYPE4 input[4]; DATA_TYPE4 w[3]; uint local_id = get_sub_group_local_id(); float4 we; we = VLD4(min(local_id, (uint)4), (__constant float *)weight_bias); int n = get_sub_group_size(); if (x < width && y < height) { output[0] = (DATA_TYPE4)(0.0f); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; input[0] = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y - 1)); input[1] = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y - 1)); input[2] = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y - 1)); input[3] = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y - 1)); w[0] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s0, 0)), as_half2(sub_group_broadcast(we.s1, 0))); w[1] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s2, 0)), as_half2(sub_group_broadcast(we.s3, 0))); w[2] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s0, 1)), as_half2(sub_group_broadcast(we.s1, 1))); output[0] = mad(w[0], input[0], output[0]); output[1] = mad(w[0], input[1], output[1]); output[0] = mad(w[1], input[1], output[0]); output[1] = mad(w[1], input[2], output[1]); output[0] = mad(w[2], input[2], output[0]); output[1] = mad(w[2], input[3], output[1]); input[0] = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 0)); input[1] = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 0)); input[2] = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 0)); input[3] = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 0)); output[2] = mad(w[0], input[0], output[2]); output[3] = mad(w[0], input[1], output[3]); output[2] = mad(w[1], input[1], output[2]); output[3] = mad(w[1], input[2], output[3]); output[2] = mad(w[2], input[2], output[2]); output[3] = mad(w[2], input[3], output[3]); w[0] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s2, 1)), as_half2(sub_group_broadcast(we.s3, 1))); w[1] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s0, 2)), as_half2(sub_group_broadcast(we.s1, 2))); w[2] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s2, 2)), as_half2(sub_group_broadcast(we.s3, 2))); output[0] = mad(w[0], input[0], output[0]); output[1] = mad(w[0], input[1], output[1]); output[0] = mad(w[1], input[1], output[0]); output[1] = mad(w[1], input[2], output[1]); output[0] = mad(w[2], input[2], output[0]); output[1] = mad(w[2], input[3], output[1]); input[0] = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 1)); input[1] = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 1)); input[2] = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 1)); input[3] = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 1)); output[2] = mad(w[0], input[0], output[2]); output[3] = mad(w[0], input[1], output[3]); output[2] = mad(w[1], input[1], output[2]); output[3] = mad(w[1], input[2], output[3]); output[2] = mad(w[2], input[2], output[2]); output[3] = mad(w[2], input[3], output[3]); w[0] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s0, 3)), as_half2(sub_group_broadcast(we.s1, 3))); w[1] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s2, 3)), as_half2(sub_group_broadcast(we.s3, 3))); w[2] = (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s0, 4)), as_half2(sub_group_broadcast(we.s1, 4))); output[0] = mad(w[0], input[0], output[0]); output[1] = mad(w[0], input[1], output[1]); output[0] = mad(w[1], input[1], output[0]); output[1] = mad(w[1], input[2], output[1]); output[0] = mad(w[2], input[2], output[0]); output[1] = mad(w[2], input[3], output[1]); input[0] = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 2)); input[1] = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 2)); input[2] = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 2)); input[3] = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 2)); output[2] = mad(w[0], input[0], output[2]); output[3] = mad(w[0], input[1], output[3]); output[2] = mad(w[1], input[1], output[2]); output[3] = mad(w[1], input[2], output[3]); output[2] = mad(w[2], input[2], output[2]); output[3] = mad(w[2], input[3], output[3]); output[0].x = dot((DATA_TYPE4)(1.0f), output[0]); output[0].y = dot((DATA_TYPE4)(1.0f), output[1]); output[0].z = dot((DATA_TYPE4)(1.0f), output[2]); output[0].w = dot((DATA_TYPE4)(1.0f), output[3]); output[0] += (DATA_TYPE4)(as_half2(sub_group_broadcast(we.s2, 4)), as_half2(sub_group_broadcast(we.s3, 4))); int pos = mad24(y, stride, x); vstore2(output[0].s01, 0, dstImg + pos); pos += stride; vstore2(output[0].s23, 0, dstImg + pos); } }
0004df95  #define DCONV_CORE(weight_bias, w, offset, inA, inB, outA, outB) \
0004dfd9  w = VLD8(offset + 0, weight_bias); \
0004dfff  outA = mad(w.lo, inA.x, outA); \
0004e021  outB = mad(w.lo, inB.x, outB); \
0004e043  outA = mad(w.hi, inA.y, outA); \
0004e065  outB = mad(w.hi, inB.y, outB); \
0004e087  w = VLD8(offset + 1, weight_bias); \
0004e0ad  outA = mad(w.lo, inA.z, outA); \
0004e0cf  outB = mad(w.lo, inB.z, outB); \
0004e0f1  outA = mad(w.hi, inA.w, outA); \
0004e113  outB = mad(w.hi, inB.w, outB); \
0004e138  __kernel void sr_deconv_4x4_s2x2_n4_c4_x2(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias, int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1) * 2; DATA_TYPE8 out[4]; DATA_TYPE8 w; DATA_TYPE4 in[4]; if (x < width && y < height) { int pos_x = (x >> 1); int pos_y = (y - 2) >> 1; out[0].lo = VLD4(64, weight_bias); out[0].hi = out[0].lo; out[1] = out[0]; out[2] = out[0]; out[3] = out[0]; in[0] = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 0)); in[1] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 0)); in[2] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 0)); in[3] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 0)); DCONV_CORE(weight_bias, w, 0, in[0], in[1], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, 2, in[1], in[2], out[0].hi, out[1].hi); DCONV_CORE(weight_bias, w, 4, in[1], in[2], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, 6, in[2], in[3], out[0].hi, out[1].hi); in[0] = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 1)); in[1] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 1)); in[2] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 1)); in[3] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 1)); DCONV_CORE(weight_bias, w, 16, in[0], in[1], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, 18, in[1], in[2], out[0].hi, out[1].hi); DCONV_CORE(weight_bias, w, 20, in[1], in[2], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, 22, in[2], in[3], out[0].hi, out[1].hi); DCONV_CORE(weight_bias, w, 8, in[0], in[1], out[2].lo, out[3].lo); DCONV_CORE(weight_bias, w, 10, in[1], in[2], out[2].hi, out[3].hi); DCONV_CORE(weight_bias, w, 12, in[1], in[2], out[2].lo, out[3].lo); DCONV_CORE(weight_bias, w, 14, in[2], in[3], out[2].hi, out[3].hi); in[0] = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 2)); in[1] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 2)); in[2] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 2)); in[3] = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 2)); DCONV_CORE(weight_bias, w, 24, in[0], in[1], out[2].lo, out[3].lo); DCONV_CORE(weight_bias, w, 26, in[1], in[2], out[2].hi, out[3].hi); DCONV_CORE(weight_bias, w, 28, in[1], in[2], out[2].lo, out[3].lo); DCONV_CORE(weight_bias, w, 30, in[2], in[3], out[2].hi, out[3].hi); 
0004eac1  #ifdef USE_BUFFER_OUT 
0004eadd  #if QUANT 
0004eaea  int pos = mad24(y, stride, x << 2); vstore16((char16)(convert_char8_sat_rte(out[0]), convert_char8_sat_rte(out[1])), 0, (__global char*)dstImg + pos); pos += stride; vstore16((char16)(convert_char8_sat_rte(out[2]), convert_char8_sat_rte(out[3])), 0, (__global char*)dstImg + pos); 
0004ec06  #else 
0004ec0f  int pos = mad24(y, stride, x << 2); vstore8(out[0], 0, dstImg + pos); vstore8(out[1], 1, dstImg + pos); pos += stride; vstore8(out[2], 0, dstImg + pos); vstore8(out[3], 1, dstImg + pos); 
0004eccd  #endif 
0004ecda  #else 
0004ece3  WRITE_IMAGE(dstImg, (int2)(x + 0, y + 0), out[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 0), out[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 0), out[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 0), out[1].hi); WRITE_IMAGE(dstImg, (int2)(x + 0, y + 1), out[2].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 1), out[2].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 1), out[3].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 1), out[3].hi); 
0004ee96  #endif 
0004eea0  } } 
0004eea7  __kernel void sr_deconv_4x4_s2x2_n4_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias, int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0)*4; int y = get_global_id(1); DATA_TYPE8 out[2]; DATA_TYPE8 w; DATA_TYPE4 in[4]; if (x < width && y < height) { out[0].lo = VLD4(64, weight_bias); out[0].hi = out[0].lo; out[1] = out[0]; int i_start = (y & 1); int offset = i_start * 8; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in[0] = READ_IMAGE(srcImg, sampler, (int2)((x - 2) >> 1, pos_y)); in[1] = READ_IMAGE(srcImg, sampler, (int2)((x + 0) >> 1, pos_y)); in[2] = READ_IMAGE(srcImg, sampler, (int2)((x + 2) >> 1, pos_y)); in[3] = READ_IMAGE(srcImg, sampler, (int2)((x + 4) >> 1, pos_y)); DCONV_CORE(weight_bias, w, offset + 0, in[0], in[1], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, offset + 2, in[1], in[2], out[0].hi, out[1].hi); DCONV_CORE(weight_bias, w, offset + 4, in[1], in[2], out[0].lo, out[1].lo); DCONV_CORE(weight_bias, w, offset + 6, in[2], in[3], out[0].hi, out[1].hi); offset += 16; } 
0004f33a  #ifdef USE_BUFFER_OUT 
0004f353  int pos = mad24(y, stride, x << 2); 
0004f37a  #if QUANT 
0004f387  vstore16((char16)(convert_char8_sat_rte(out[0]), convert_char8_sat_rte(out[1])), 0, (__global char*)dstImg + pos); 
0004f3fd  #else 
0004f406  vstore8(out[0], 0, dstImg + pos); vstore8(out[1], 0, dstImg + pos + 8); 
0004f451  #endif 
0004f45e  #else 
0004f467  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out[0].lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out[0].hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y), out[1].lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y), out[1].hi); 
0004f532  #endif 
0004f53c  } } 
0004f544 __kernel void sr_conv_3x3_s1x1_n8_c8_conv_1x1_s1x1_n8_c8(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half weight_bias_3x3[585], __constant half weight_bias_1x1[108], int width, int height, int stride, int merge1x1) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0) << 1); int y = get_global_id(1); uint local_id = get_sub_group_local_id(); int i, j; DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1; DATA_TYPE8 w; float4 we; if (x < width && y < height) { 
0004f760  #ifdef GROUP_CONV 
0004f775  out0 = VLD8(36, weight_bias_3x3); 
0004f79a  #else 
0004f7a3  out0 = VLD8(72, weight_bias_3x3); 
0004f7c8  #endif 
0004f7d2  out1 = out0; short offset = 0; for (i = 0; i < 3; i++) { int pos_y = y + i - 1; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y)); for (j = 0; j < 3; j++) { in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, pos_y)); pos_x += 2; 
0004f967  #ifdef GROUP_CONV 
0004f97c  if (local_id < 4) we = VLD4(offset + local_id, (__constant float *)weight_bias_3x3); SR_CONV_3x3_CORE_G(we, in0, in1); offset += 4; 
0004fa03  #else 
0004fa0c  we = VLD4(offset + local_id, (__constant float *)weight_bias_3x3); SR_CONV_3x3_CORE_B(we, in0, in1); offset += 8; 
0004fa81  #endif 
0004fa8b  in0 = in1; } } in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); out0 = VLD8(8, weight_bias_1x1); out1 = out0; we = VLD4(local_id, (__constant float *)weight_bias_1x1); SR_CONV_3x3_CORE_B(we, in0, in1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 0, y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 1, y)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 2, y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(2 * x + 3, y)); 
0004fc63  #ifdef GROUP_CONV 
0004fc78  DATA_TYPE q = VLD(0, weight_bias_3x3 + 296); 
0004fca8  #else 
0004fcb1  DATA_TYPE q = VLD(0, weight_bias_3x3 + 584); 
0004fce1  #endif 
0004fceb  out0 = mad(in0, q, out0); out1 = mad(in1, q, out1); if (merge1x1) { in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); out0.lo = VLD4(8, weight_bias_1x1 + 72); out0.hi = out0.lo; w = VLD8(0, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s0, out0.lo); out0.hi = mad(w.lo, in1.s0, out0.hi); out0.lo = mad(w.hi, in0.s1, out0.lo); out0.hi = mad(w.hi, in1.s1, out0.hi); w = VLD8(1, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s2, out0.lo); out0.hi = mad(w.lo, in1.s2, out0.hi); out0.lo = mad(w.hi, in0.s3, out0.lo); out0.hi = mad(w.hi, in1.s3, out0.hi); w = VLD8(2, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s4, out0.lo); out0.hi = mad(w.lo, in1.s4, out0.hi); out0.lo = mad(w.hi, in0.s5, out0.lo); out0.hi = mad(w.hi, in1.s5, out0.hi); w = VLD8(3, weight_bias_1x1 + 72); out0.lo = mad(w.lo, in0.s6, out0.lo); out0.hi = mad(w.lo, in1.s6, out0.hi); out0.lo = mad(w.hi, in0.s7, out0.lo); out0.hi = mad(w.hi, in1.s7, out0.hi); 
000500a6  #ifdef USE_BUFFER_OUT 
000500bf  int pos = mad24(y, stride, x << 2); vstore8(out0, 0, dstImg + pos + 0); 
0005010a  #else 
00050113  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out0.hi); 
00050176  #endif 
00050180  } else { out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); 
000501da  #ifdef USE_BUFFER_OUT 
000501f3  int pos = mad24(y, stride, x << 3); 
0005021a  #if QUANT 
00050227  vstore16((uchar16)(convert_uchar8_sat_rte(out0), convert_uchar8_sat_rte(out1)), 0, (__global unsigned char*)dstImg + pos); 
000502a5  #else 
000502ae  vstore8(out0, 0, dstImg + pos + 0); vstore8(out1, 0, dstImg + pos + 8); 
000502f9  #endif 
00050306  #else 
0005030f  WRITE_IMAGE(dstImg, (int2)(2 * x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(2 * x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 3, y), out1.hi); 
000503e2  #endif 
000503ec  } } }
000503f3 __kernel void sr_conv_3x3_s1x1_n8_c1(__read_only image2d_t srcImg, __global DATA_TYPE* dstBuf,__write_only image2d_t dstImg, __constant half *weight_bias_slope __ATTRIBUTE_MAX_CONSANT_SIZE_(88 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0); int y = get_global_id(1); DATA_TYPE8 out0, out1, out2, out3; if (x * 4 < width && y < height) { out0 = VLD8(9, weight_bias_slope); out1 = out0; out2 = out0; out3 = out0; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2; in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y - 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y - 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y - 1)); w = VLD8(0, weight_bias_slope); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(1, weight_bias_slope); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(2, weight_bias_slope); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 0)); w = VLD8(3, weight_bias_slope); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(4, weight_bias_slope); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(5, weight_bias_slope); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 1)); w = VLD8(6, weight_bias_slope); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(7, weight_bias_slope); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(8, weight_bias_slope); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); w = VLD8(10, weight_bias_slope); out0 = fmax(out0, (DATA_TYPE8)(0.0f)) + w * fmin(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)) + w * fmin(out1, (DATA_TYPE8)(0.0f)); out2 = fmax(out2, (DATA_TYPE8)(0.0f)) + w * fmin(out2, (DATA_TYPE8)(0.0f)); out3 = fmax(out3, (DATA_TYPE8)(0.0f)) + w * fmin(out3, (DATA_TYPE8)(0.0f)); 
00050e9a  #if QUANT 
00050ea7  int pos = mad24(y + 1, stride, (x * 4 + 1) << 3); __global char* dstPtr = (__global char*)dstBuf + pos; vstore8(convert_char8_sat_rte(out0), 0, dstPtr); vstore8(convert_char8_sat_rte(out1), 1, dstPtr); vstore8(convert_char8_sat_rte(out2), 2, dstPtr); vstore8(convert_char8_sat_rte(out3), 3, dstPtr); 
00050fd6  #else 
00050fdf  int pos = mad24(y + 1, stride, (x * 4 + 1) << 3); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); vstore8(out2, 2, dstBuf + pos); vstore8(out3, 3, dstBuf + pos); 
00051094  #endif 
0005109e  } } 
000510a8  #define SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias) \
000510f4  w = VLD8(offset + 0, weight_bias); \
0005111a  out0 = mad(w, in0.s0, out0); \
0005113a  out1 = mad(w, in1.s0, out1); \
0005115a  w = VLD8(offset + 1, weight_bias); \
00051180  out0 = mad(w, in0.s1, out0); \
000511a0  out1 = mad(w, in1.s1, out1); \
000511c0  w = VLD8(offset + 2, weight_bias); \
000511e6  out0 = mad(w, in0.s2, out0); \
00051206  out1 = mad(w, in1.s2, out1); \
00051226  w = VLD8(offset + 3, weight_bias); \
0005124c  out0 = mad(w, in0.s3, out0); \
0005126c  out1 = mad(w, in1.s3, out1); \
0005128c  w = VLD8(offset + 4, weight_bias); \
000512b2  out0 = mad(w, in0.s4, out0); \
000512d2  out1 = mad(w, in1.s4, out1); \
000512f2  w = VLD8(offset + 5, weight_bias); \
00051318  out0 = mad(w, in0.s5, out0); \
00051338  out1 = mad(w, in1.s5, out1); \
00051358  w = VLD8(offset + 6, weight_bias); \
0005137e  out0 = mad(w, in0.s6, out0); \
0005139e  out1 = mad(w, in1.s6, out1); \
000513be  w = VLD8(offset + 7, weight_bias); \
000513e4  out0 = mad(w, in0.s7, out0); \
00051404  out1 = mad(w, in1.s7, out1); \
00051427  __kernel void sr_conv_3x3_s1x1_n8_c8_prelu(__global DATA_TYPE *srcBuf, __read_only image2d_t srcImg, __global DATA_TYPE *dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias_slope __ATTRIBUTE_MAX_CONSANT_SIZE_(593 * sizeof(half)), int width, int height, int stride, int idx) { short x = get_global_id(0) * 2; short y = get_global_id(1); DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1, in2, in3; DATA_TYPE8 w; int vstride = stride >> 3; if (x < width && y < height) { out0 = VLD8(72, weight_bias_slope); out1 = out0; 
00051639  #ifdef USE_IMAGE 
0005164d  const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y - 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y - 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y - 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y - 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y - 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y - 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y - 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y - 1)); 
000518cc  #elif QUANT 
000518db  char16 pix0, pix1; int pos = mad24(y, vstride, x + 1); pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
00051987  #else
0005198f  int pos = mad24(y, vstride, x + 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
00051a32  #endif 
00051a3f  #if !defined(USE_IMAGE) && QUANT 
00051a63  SR_CONV_3x3_CORE_B(w, pix0.lo, pix0.hi, out0, out1, 0, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix0.hi, pix1.lo, out0, out1, 8, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix1.lo, pix1.hi, out0, out1, 16, weight_bias_slope); 
00051b48  #else 
00051b51  SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, 0, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in1, in2, out0, out1, 8, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in2, in3, out0, out1, 16, weight_bias_slope); 
00051c1e  #endif 
00051c2b  #ifdef USE_IMAGE 
00051c3f  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 1)); 
00051e42  #elif QUANT 
00051e51  pos += (vstride << 1); pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
00051edd  #else 
00051ee6  pos += (vstride << 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
00051f7c  #endif 
00051f89  #if !defined(USE_IMAGE) && QUANT 
00051fad  SR_CONV_3x3_CORE_B(w, pix0.lo, pix0.hi, out0, out1, 48, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix0.hi, pix1.lo, out0, out1, 56, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix1.lo, pix1.hi, out0, out1, 64, weight_bias_slope); 
00052094  #else 
0005209d  SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, 48, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in1, in2, out0, out1, 56, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in2, in3, out0, out1, 64, weight_bias_slope); 
0005216c  #endif 
00052179  #ifdef USE_IMAGE 
0005218d  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 0)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 0)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 0)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 0)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 0)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 0)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 0)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 0)); 
00052390  #elif QUANT 
0005239f  pos -= vstride; pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
00052424  #else 
0005242d  pos -= vstride; in0 = vload8(pos - 1, srcBuf); in3 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in1 = vload8(pos + 2, srcBuf); 
000524bc  #endif 
000524c9  #if !defined(USE_IMAGE) && QUANT 
000524ed  SR_CONV_3x3_CORE_B(w, pix0.lo, pix0.hi, out0, out1, 24, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix0.hi, pix1.lo, out0, out1, 32, weight_bias_slope); SR_CONV_3x3_CORE_B(w, pix1.lo, pix1.hi, out0, out1, 40, weight_bias_slope); 
000525d4  #else 
000525dd  SR_CONV_3x3_CORE_B(w, in0, in3, out0, out1, 24, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in3, in2, out0, out1, 32, weight_bias_slope); SR_CONV_3x3_CORE_B(w, in2, in1, out0, out1, 40, weight_bias_slope); 
000526ac  #endif 
000526b6  w = VLD8(73, weight_bias_slope); out0 = fmax(out0, (DATA_TYPE8)(0.0f)) + w * fmin(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)) + w * fmin(out1, (DATA_TYPE8)(0.0f)); 
00052772  #ifdef USE_IMAGE 
00052786  WRITE_IMAGE(dstImg, (int2)(pos_x + 2, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 3, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 4, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 5, y), out1.hi); 
00052859  #elif QUANT 
00052868  vstore16((char16)(convert_char8_sat_rte(out0), convert_char8_sat_rte(out1)), 0, (__global char*)dstBuf + pos * 8); 
000528de  #else 
000528e7  vstore8(out0, pos + 0, dstBuf); vstore8(out1, pos + 1, dstBuf); 
0005292a  #endif 
00052934  } }
0005293b  #define SR_CONV_3x3_CORE_A(w, in0, in1, out0, out1, offset, weight_bias) \
00052987  w = VLD4(offset + 0, weight_bias); \
000529ad  out0 = mad(w, in0.s0, out0); \
000529cd  out1 = mad(w, in1.s0, out1); \
000529ed  w = VLD4(offset + 1, weight_bias); \
00052a13  out0 = mad(w, in0.s1, out0); \
00052a33  out1 = mad(w, in1.s1, out1); \
00052a53  w = VLD4(offset + 2, weight_bias); \
00052a79  out0 = mad(w, in0.s2, out0); \
00052a99  out1 = mad(w, in1.s2, out1); \
00052ab9  w = VLD4(offset + 3, weight_bias); \
00052adf  out0 = mad(w, in0.s3, out0); \
00052aff  out1 = mad(w, in1.s3, out1); \
00052b1f  w = VLD4(offset + 4, weight_bias); \
00052b45  out0 = mad(w, in0.s4, out0); \
00052b65  out1 = mad(w, in1.s4, out1); \
00052b85  w = VLD4(offset + 5, weight_bias); \
00052bab  out0 = mad(w, in0.s5, out0); \
00052bcb  out1 = mad(w, in1.s5, out1); \
00052beb  w = VLD4(offset + 6, weight_bias); \
00052c11  out0 = mad(w, in0.s6, out0); \
00052c31  out1 = mad(w, in1.s6, out1); \
00052c51  w = VLD4(offset + 7, weight_bias); \
00052c77  out0 = mad(w, in0.s7, out0); \
00052c97  out1 = mad(w, in1.s7, out1); \
00052cba  __kernel void sr_conv_3x3_s1x1_n4_c8(__global DATA_TYPE *srcBuf, __read_only image2d_t srcImg, __global DATA_TYPE *dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias_slope __ATTRIBUTE_MAX_CONSANT_SIZE_(292 * sizeof(half)), int width, int height, int stride_in, int stride_out) { short x = get_global_id(0) * 2; short y = get_global_id(1); DATA_TYPE8 out; DATA_TYPE8 in0, in1, in2, in3; DATA_TYPE4 w; int vstride_in = stride_in >> 3; int vstride_out = stride_out >> 2; if (x < width && y < height) { out.lo = VLD4(72, weight_bias_slope); out.hi = out.lo; 
00052ef8  #ifdef USE_IMAGE 
00052f0c  const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y - 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y - 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y - 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y - 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y - 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y - 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y - 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y - 1)); 
0005318b  #elif QUANT 
0005319a  char16 pix0, pix1; int pos = mad24(y, vstride_in, x + 1); pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
00053249  #else
00053251  int pos = mad24(y, vstride_in, x + 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
000532f7  #endif 
00053304  #if !defined(USE_IMAGE) && QUANT 
00053328  SR_CONV_3x3_CORE_A(w, pix0.lo, pix0.hi, out.lo, out.hi, 0, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix0.hi, pix1.lo, out.lo, out.hi, 8, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix1.lo, pix1.hi, out.lo, out.hi, 16, weight_bias_slope); 
00053419  #else 
00053422  SR_CONV_3x3_CORE_A(w, in0, in1, out.lo, out.hi, 0, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in1, in2, out.lo, out.hi, 8, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in2, in3, out.lo, out.hi, 16, weight_bias_slope); 
000534fb  #endif 
00053508  #ifdef USE_IMAGE 
0005351c  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 1)); 
0005371f  #elif QUANT 
0005372e  pos += (vstride_in << 1); pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
000537bd  #else 
000537c6  pos += (vstride_in << 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
0005385f  #endif 
0005386c  #if !defined(USE_IMAGE) && QUANT 
00053890  SR_CONV_3x3_CORE_A(w, pix0.lo, pix0.hi, out.lo, out.hi, 48, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix0.hi, pix1.lo, out.lo, out.hi, 56, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix1.lo, pix1.hi, out.lo, out.hi, 64, weight_bias_slope); 
00053983  #else 
0005398c  SR_CONV_3x3_CORE_A(w, in0, in1, out.lo, out.hi, 48, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in1, in2, out.lo, out.hi, 56, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in2, in3, out.lo, out.hi, 64, weight_bias_slope); 
00053a67  #endif 
00053a74  #ifdef USE_IMAGE 
00053a88  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 0)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 0)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 0)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 0)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 0)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 0)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 0)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 0)); 
00053c8b  #elif QUANT 
00053c9a  pos -= vstride_in; pix0 = VLD16(0, (__global char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global char*)srcBuf + (pos + 1) * 8); 
00053d22  #else 
00053d2b  pos -= vstride_in; in0 = vload8(pos - 1, srcBuf); in3 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in1 = vload8(pos + 2, srcBuf); 
00053dbd  #endif 
00053dca  #if !defined(USE_IMAGE) && QUANT 
00053dee  SR_CONV_3x3_CORE_A(w, pix0.lo, pix0.hi, out.lo, out.hi, 24, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix0.hi, pix1.lo, out.lo, out.hi, 32, weight_bias_slope); SR_CONV_3x3_CORE_A(w, pix1.lo, pix1.hi, out.lo, out.hi, 40, weight_bias_slope); 
00053ee1  #else 
00053eea  SR_CONV_3x3_CORE_A(w, in0, in3, out.lo, out.hi, 24, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in3, in2, out.lo, out.hi, 32, weight_bias_slope); SR_CONV_3x3_CORE_A(w, in2, in1, out.lo, out.hi, 40, weight_bias_slope); 
00053fc5  #endif 
00053fd2  #ifdef USE_IMAGE 
00053fe6  WRITE_IMAGE(dstImg, (int2)(pos_x + 0, y), out.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 1, y), out.hi); 
0005404f  #elif QUANT 
0005405e  pos = y * vstride_out + x; vstore8(convert_char8_sat_rte(out), 0, (__global char*)dstBuf + pos * 4); 
000540c6  #else 
000540cf  pos = y * vstride_out + x; vstore4(out.lo, pos + 0, dstBuf); vstore4(out.hi, pos + 1, dstBuf); 
00054131  #endif 
0005413b  } }
00054140 __kernel void sr_deconv_4x4_s2x2_n1_c4_resize_2x2_add(__read_only image2d_t srcImg0, __read_only image2d_t srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(65 * sizeof(half)), int width, int height, int stride_in1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 8; int y = get_global_id(1); DATA_TYPE8 out; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2, in3, in4, in5; int width_in1 = (width >> 1); int height_in1 = (height >> 1); if (x < width && y < height) { out.s0 = VLD(64, weight_bias); out.s1 = out.s0; out.s2 = out.s0; out.s3 = out.s0; out.hi = out.lo; int i_start = (y & 1); int offset = i_start * 2; int pos; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in0 = READ_IMAGE(srcImg0, sampler, (int2)((x - 2) >> 1, pos_y)); in1 = READ_IMAGE(srcImg0, sampler, (int2)((x + 0) >> 1, pos_y)); in2 = READ_IMAGE(srcImg0, sampler, (int2)((x + 2) >> 1, pos_y)); in3 = READ_IMAGE(srcImg0, sampler, (int2)((x + 4) >> 1, pos_y)); in4 = READ_IMAGE(srcImg0, sampler, (int2)((x + 6) >> 1, pos_y)); in5 = READ_IMAGE(srcImg0, sampler, (int2)((x + 8) >> 1, pos_y)); w = VLD8(offset + 0, weight_bias); out.s0 += dot(w.lo, in0); out.s1 += dot(w.hi, in1); out.s2 += dot(w.lo, in1); out.s3 += dot(w.hi, in2); out.s4 += dot(w.lo, in2); out.s5 += dot(w.hi, in3); out.s6 += dot(w.lo, in3); out.s7 += dot(w.hi, in4); w = VLD8(offset + 1, weight_bias); out.s0 += dot(w.lo, in1); out.s1 += dot(w.hi, in2); out.s2 += dot(w.lo, in2); out.s3 += dot(w.hi, in3); out.s4 += dot(w.lo, in3); out.s5 += dot(w.hi, in4); out.s6 += dot(w.lo, in4); out.s7 += dot(w.hi, in5); offset += 4; } int x1 = (x >> 3); int y1 = (y >> 1); DATA_TYPE8 inA, inB; inA.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1)); inA.s4 = inA.s3; if ((x >> 1) + 4 < width_in1) { inA.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1)); } inA.s4567 = (inA.s0123 + inA.s1234) * (DATA_TYPE)(0.5f); UGENTYPE8 mask = (UGENTYPE8)(0, 4, 1, 5, 2, 6, 3, 7); inA = shuffle(inA, mask); if ((y & 1) == 1 && y < height - 1) { inB.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1 + 1)); inB.s4 = inA.s3; if ((x >> 1) + 4 < width_in1) { inB.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1 + 1)); } inB.s4567 = (inB.s0123 + inB.s1234) * (DATA_TYPE)(0.5f); UGENTYPE8 mask = (UGENTYPE8)(0, 4, 1, 5, 2, 6, 3, 7); inB = shuffle(inB, mask); inA = (inA + inB)*(DATA_TYPE)(0.5f); } out += inA; out *= (DATA_TYPE)(255.0f); pos = mad24(y, stride_out, x); vstore8(convert_uchar8_sat(out), 0, dstImg + pos); } } 
00054b74 __kernel void sr_resize_2x2_add(__read_only image2d_t srcImg0, __read_only image2d_t srcImg1, __global unsigned char* dstImg, int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE8 out[2]; DATA_TYPE4 in00, in01, in02, in03; DATA_TYPE16 inA, inB; int width_in_1 = (width >> 1); int height_in_1 = (height >> 1); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { x1 = (x >> 1); y1 = y >> 1; inA.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1)); inA.s4 = inA.s3; if ((x << 1) + 4 < width_in_1) { inA.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1)); } inA.s89ab = (inA.s0123 + inA.s1234) * (DATA_TYPE)(0.5f); UGENTYPE8 mask = (UGENTYPE8)(0, 4, 1, 5, 2, 6, 3, 7); inA.lo = shuffle2(inA.s0123, inA.s89ab, mask); if (y1 == height_in_1 - 1) y1 -= 1; inB.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1 + 1)); inB.s4 = inB.s3; if ((x << 1) + 4 < width_in_1) { inB.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1 + 1)); } inB.s89ab = (inB.s0123 + inB.s1234) * (DATA_TYPE)(0.5f); inB.lo = shuffle2(inB.s0123, inB.s89ab, mask); inA.hi = (inA.lo + inB.lo) * (DATA_TYPE)(0.5f); in00 = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y)); in01 = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y)); in02 = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 1)); in03 = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 1)); out[0].lo = inA.s0123 + in00; out[0].hi = inA.s4567 + in01; out[1].lo = inA.s89ab + in02; out[1].hi = inA.scdef + in03; out[0] = mad(out[0], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out[1] = mad(out[1], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); int pos = mad24(y, stride, x * 4); vstore8(convert_uchar8_sat(out[0]), 0, dstImg + pos); vstore8(convert_uchar8_sat(out[1]), 0, dstImg + pos + stride); } }
000552e5 __kernel void sr_resize_3x3_add(__read_only image2d_t srcImg0, __read_only image2d_t srcImg1, __global unsigned char* dstImg, int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_NEAREST; int x = get_global_id(0) * 3; int y = get_global_id(1) * 3; DATA_TYPE4 in0[9]; DATA_TYPE16 inA, inB, out, out1; int width_in_1 = (width / 3); int height_in_1 = (height / 3); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { x1 = (x / 3); y1 = y / 3; inA.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1)); inA.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1)); inA.s89ab = inA.s0123 * (DATA_TYPE)(0.6666666f) + inA.s1234 * (DATA_TYPE)(0.3333333f); inA.scdef = inA.s0123 * (DATA_TYPE)(0.3333333f) + inA.s1234 * (DATA_TYPE)(0.6666666f); UGENTYPE16 mask = (UGENTYPE16)(0, 8, 12, 1, 9, 13, 2, 10, 14, 3, 11, 15, 4, 5, 6, 7); inA = shuffle(inA, mask); inB.s0123 = READ_IMAGE(srcImg1, sampler, (int2)(x1, y1 + 1)); inB.s4567 = READ_IMAGE(srcImg1, sampler, (int2)(x1 + 1, y1 + 1)); inB.s89ab = inB.s0123 * (DATA_TYPE)(0.6666666f) + inB.s1234 * (DATA_TYPE)(0.3333333f); inB.scdef = inB.s0123 * (DATA_TYPE)(0.3333333f) + inB.s1234 * (DATA_TYPE)(0.6666666f); inB = shuffle(inB, mask); out = inA * (DATA_TYPE)(0.6666666f) + inB * (DATA_TYPE)(0.3333333f); out1 = inA * (DATA_TYPE)(0.3333333f) + inB * (DATA_TYPE)(0.6666666f); in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 1)); in0[4] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 1)); in0[5] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y + 1)); in0[6] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 2)); in0[7] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 2)); in0[8] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y + 2)); inA.s0123 = inA.s0123 + in0[0]; inA.s4567 = inA.s4567 + in0[1]; inA.s89ab = inA.s89ab + in0[2]; out.s0123 = out.s0123 + in0[3]; out.s4567 = out.s4567 + in0[4]; out.s89ab = out.s89ab + in0[5]; out1.s0123 = out1.s0123 + in0[6]; out1.s4567 = out1.s4567 + in0[7]; out1.s89ab = out1.s89ab + in0[8]; inA = mad(inA, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out = mad(out, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out1 = mad(out1, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); int pos = mad24(y, stride, out_x); vstore8(convert_uchar8_sat(inA.lo), 0, dstImg + pos); vstore4(convert_uchar4_sat(inA.s89ab), 0, dstImg + pos + 8); vstore8(convert_uchar8_sat(out.lo), 0, dstImg + pos + stride); vstore4(convert_uchar4_sat(out.s89ab), 0, dstImg + pos + stride + 8); vstore8(convert_uchar8_sat(out1.lo), 0, dstImg + pos + 2 * stride); vstore4(convert_uchar4_sat(out1.s89ab), 0, dstImg + pos + 2 * stride + 8); } }
00055e14 __kernel void sr_conv_3x3_s1x1_n8_c1(__read_only image2d_t srcImg, __global DATA_TYPE* dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(80 * sizeof(half)), __constant half *weight_bias1x1 __ATTRIBUTE_MAX_CONSANT_SIZE_(36 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0); int y = get_global_id(1); DATA_TYPE8 out0, out1, out2, out3; DATA_TYPE8 in[4]; if (x * 4 < width && y < height) { out0 = VLD8(9, weight_bias); out1 = out0; out2 = out0; out3 = out0; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2; in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y - 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y - 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y - 1)); w = VLD8(0, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(1, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(2, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 0)); w = VLD8(3, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(4, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(5, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 1)); w = VLD8(6, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(7, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(8, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in[0] = fmax(out0, (DATA_TYPE8)(0.0f)); in[1] = fmax(out1, (DATA_TYPE8)(0.0f)); in[2] = fmax(out2, (DATA_TYPE8)(0.0f)); in[3] = fmax(out3, (DATA_TYPE8)(0.0f)); out0.lo = VLD4(8, weight_bias1x1); out0.hi = out0.lo; out1 = out0; w = VLD8(0, weight_bias1x1); out0.lo = mad(w.lo, in[0].s0, out0.lo); out0.hi = mad(w.lo, in[1].s0, out0.hi); out1.lo = mad(w.lo, in[2].s0, out1.lo); out1.hi = mad(w.lo, in[3].s0, out1.hi); out0.lo = mad(w.hi, in[0].s1, out0.lo); out0.hi = mad(w.hi, in[1].s1, out0.hi); out1.lo = mad(w.hi, in[2].s1, out1.lo); out1.hi = mad(w.hi, in[3].s1, out1.hi); w = VLD8(1, weight_bias1x1); out0.lo = mad(w.lo, in[0].s2, out0.lo); out0.hi = mad(w.lo, in[1].s2, out0.hi); out1.lo = mad(w.lo, in[2].s2, out1.lo); out1.hi = mad(w.lo, in[3].s2, out1.hi); out0.lo = mad(w.hi, in[0].s3, out0.lo); out0.hi = mad(w.hi, in[1].s3, out0.hi); out1.lo = mad(w.hi, in[2].s3, out1.lo); out1.hi = mad(w.hi, in[3].s3, out1.hi); w = VLD8(2, weight_bias1x1); out0.lo = mad(w.lo, in[0].s4, out0.lo); out0.hi = mad(w.lo, in[1].s4, out0.hi); out1.lo = mad(w.lo, in[2].s4, out1.lo); out1.hi = mad(w.lo, in[3].s4, out1.hi); out0.lo = mad(w.hi, in[0].s5, out0.lo); out0.hi = mad(w.hi, in[1].s5, out0.hi); out1.lo = mad(w.hi, in[2].s5, out1.lo); out1.hi = mad(w.hi, in[3].s5, out1.hi); w = VLD8(3, weight_bias1x1); out0.lo = mad(w.lo, in[0].s6, out0.lo); out0.hi = mad(w.lo, in[1].s6, out0.hi); out1.lo = mad(w.lo, in[2].s6, out1.lo); out1.hi = mad(w.lo, in[3].s6, out1.hi); out0.lo = mad(w.hi, in[0].s7, out0.lo); out0.hi = mad(w.hi, in[1].s7, out0.hi); out1.lo = mad(w.hi, in[2].s7, out1.lo); out1.hi = mad(w.hi, in[3].s7, out1.hi); int pos_x = (x << 2); WRITE_IMAGE(dstImg, (int2)(pos_x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 3, y), out1.hi); } } 
00056ecf __kernel void sr_deconv_4x4_s2x2_n4_c4(__read_only image2d_t srcImg, __global DATA_TYPE* dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(68 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1) * 2; DATA_TYPE8 out0, out1; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2, in3; if (x < width && y < height) { int pos_x = (x >> 1); int pos_y = (y - 2) >> 1; in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 0)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 0)); out0.lo = VLD4(16, weight_bias); out0.hi = out0.lo; out1 = out0; w = VLD8(0, weight_bias); out0.lo = mad(w.lo, in0, out0.lo); out0.hi = mad(w.hi, in1, out0.hi); out1.lo = mad(w.lo, in1, out1.lo); out1.hi = mad(w.hi, in2, out1.hi); w = VLD8(1, weight_bias); out0.lo = mad(w.lo, in1, out0.lo); out0.hi = mad(w.hi, in2, out0.hi); out1.lo = mad(w.lo, in2, out1.lo); out1.hi = mad(w.hi, in3, out1.hi); in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 1 + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 1 + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 1 + 0)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 1 + 0)); w = VLD8(4, weight_bias); out0.lo = mad(w.lo, in0, out0.lo); out0.hi = mad(w.hi, in1, out0.hi); out1.lo = mad(w.lo, in1, out1.lo); out1.hi = mad(w.hi, in2, out1.hi); w = VLD8(5, weight_bias); out0.lo = mad(w.lo, in1, out0.lo); out0.hi = mad(w.hi, in2, out0.hi); out1.lo = mad(w.lo, in2, out1.lo); out1.hi = mad(w.hi, in3, out1.hi); 
000575e5  #ifdef USE_IMAGE 
000575f9  WRITE_IMAGE(dstImg, (int2)(x + 0, y + 0), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 0), out0.hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 0), out1.lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 0), out1.hi); 
000576cc  #elif QUANT 
000576db  int pos = mad24(y + 0, stride, x << 2); vstore16((char16)(convert_char8_sat_rte(out0), convert_char8_sat_rte(out1)), 0, (__global char*)dstBuf + pos); 
00057775  #else 
0005777e  int pos = mad24(y + 0, stride, x << 2); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); 
000577e9  #endif 
000577f3  out0.lo = VLD4(16, weight_bias); out0.hi = out0.lo; out1 = out0; w = VLD8(2, weight_bias); out0.lo = mad(w.lo, in0, out0.lo); out0.hi = mad(w.hi, in1, out0.hi); out1.lo = mad(w.lo, in1, out1.lo); out1.hi = mad(w.hi, in2, out1.hi); w = VLD8(3, weight_bias); out0.lo = mad(w.lo, in1, out0.lo); out0.hi = mad(w.hi, in2, out0.hi); out1.lo = mad(w.lo, in2, out1.lo); out1.hi = mad(w.hi, in3, out1.hi); in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 1 + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 1 + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 1 + 1)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 1 + 1)); w = VLD8(6, weight_bias); out0.lo = mad(w.lo, in0, out0.lo); out0.hi = mad(w.hi, in1, out0.hi); out1.lo = mad(w.lo, in1, out1.lo); out1.hi = mad(w.hi, in2, out1.hi); w = VLD8(7, weight_bias); out0.lo = mad(w.lo, in1, out0.lo); out0.hi = mad(w.hi, in2, out0.hi); out1.lo = mad(w.lo, in2, out1.lo); out1.hi = mad(w.hi, in3, out1.hi); 
00057be3  #ifdef USE_IMAGE 
00057bf7  WRITE_IMAGE(dstImg, (int2)(x + 0, y + 1), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 1), out0.hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 1), out1.lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 1), out1.hi); 
00057cca  #else 
00057cd3  pos = mad24(y + 1, stride, x << 2); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); 
00057d3a  #endif 
00057d44  } }
00057d49 __kernel void sr_conv_3x3_s1x1_n8_c1(__read_only image2d_t srcImg, __global DATA_TYPE* dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(80 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0); int y = get_global_id(1); DATA_TYPE8 out0, out1, out2, out3; if (x * 4 < width && y < height) { out0 = VLD8(9, weight_bias); out1 = out0; out2 = out0; out3 = out0; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2; in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y - 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y - 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y - 1)); w = VLD8(0, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(1, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(2, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 0)); w = VLD8(3, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(4, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(5, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 1)); w = VLD8(6, weight_bias); out0 = mad(w, in0.w, out0); out1 = mad(w, in1.x, out1); out2 = mad(w, in1.y, out2); out3 = mad(w, in1.z, out3); w = VLD8(7, weight_bias); out0 = mad(w, in1.x, out0); out1 = mad(w, in1.y, out1); out2 = mad(w, in1.z, out2); out3 = mad(w, in1.w, out3); w = VLD8(8, weight_bias); out0 = mad(w, in1.y, out0); out1 = mad(w, in1.z, out1); out2 = mad(w, in1.w, out2); out3 = mad(w, in2.x, out3); 
0005865e  #ifdef USE_IMAGE 
00058672  out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); out2 = fmax(out2, (DATA_TYPE8)(0.0f)); out3 = fmax(out3, (DATA_TYPE8)(0.0f)); int pos_x = (x << 3); WRITE_IMAGE(dstImg, (int2)(pos_x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 3, y), out1.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 4, y), out2.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 5, y), out2.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 6, y), out3.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 7, y), out3.hi); 
000588c7  #elif QUANT 
000588d6  int pos = mad24(y + 1, stride, (x * 4 + 1) << 3); __global unsigned char* dstPtr = (__global unsigned char*)dstBuf + pos; vstore8(convert_uchar8_sat_rte(out0), 0, dstPtr); vstore8(convert_uchar8_sat_rte(out1), 1, dstPtr); vstore8(convert_uchar8_sat_rte(out2), 2, dstPtr); vstore8(convert_uchar8_sat_rte(out3), 3, dstPtr); 
00058a1b  #else 
00058a24  out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); out2 = fmax(out2, (DATA_TYPE8)(0.0f)); out3 = fmax(out3, (DATA_TYPE8)(0.0f)); int pos = mad24(y + 1, stride, (x * 4 + 1) << 3); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); vstore8(out2, 2, dstBuf + pos); vstore8(out3, 3, dstBuf + pos); 
00058b75  #endif 
00058b7f  } } 
00058b89  #define SR_CONV_2x2_CORE(offset, out0, out1) \
00058bb9  w[0] = VLD2(offset + 0, weight_bias); \
00058be2  w[1] = VLD2(offset + 1, weight_bias); \
00058c0b  w[2] = VLD2(offset + 2, weight_bias); \
00058c34  out0 = mad((DATA_TYPE4)(in0[0].w, in0[1].x, in0[1].y, in0[1].z), w[0].x, out0); \
00058c87  out1 = mad((DATA_TYPE4)(in0[1].w, in0[2].x, in0[2].y, in0[2].z), w[0].x, out1); \
00058cda  out0 = mad(in0[1], w[1].x, out0); \
00058cff  out1 = mad(in0[2], w[1].x, out1); \
00058d24  out0 = mad((DATA_TYPE4)(in0[1].y, in0[1].z, in0[1].w, in0[2].x), w[2].x, out0); \
00058d77  out1 = mad((DATA_TYPE4)(in0[2].y, in0[2].z, in0[2].w, in0[3].x), w[2].x, out1); \
00058dca  out0 = mad((DATA_TYPE4)(in1[0].w, in1[1].x, in1[1].x, in1[1].y), w[0].y, out0); \
00058e1d  out1 = mad((DATA_TYPE4)(in1[1].y, in1[1].z, in1[1].z, in1[1].w), w[0].y, out1); \
00058e70  out0 = mad((DATA_TYPE4)(in1[1].x, in1[1].x, in1[1].y, in1[1].y), w[1].y, out0); \
00058ec3  out1 = mad((DATA_TYPE4)(in1[1].z, in1[1].z, in1[1].w, in1[1].w), w[1].y, out1); \
00058f16  out0 = mad((DATA_TYPE4)(in1[1].x, in1[1].y, in1[1].y, in1[1].z), w[2].y, out0); \
00058f69  out1 = mad((DATA_TYPE4)(in1[1].z, in1[1].w, in1[1].w, in1[2].x), w[2].y, out1); \
00058fbf  __kernel void sr_conv_2x2_s1x1_n1_c2(__read_only image2d_t srcImg0, __read_only image2d_t srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(26 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE8 out[2]; DATA_TYPE2 w[3]; DATA_TYPE4 in0[4], in1[3]; if (x * 4 < width && y < height) { DATA_TYPE bias = VLD(18, weight_bias); out[0] = (DATA_TYPE8)(bias); out[1] = out[0]; int pos_y = y - 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1[0] = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, pos_y >> 1)); in1[1] = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, pos_y >> 1)); in1[2] = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, pos_y >> 1)); SR_CONV_2x2_CORE(0, out[0].lo, out[0].hi); pos_y = y + 0; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1[0] = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, pos_y >> 1)); in1[1] = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, pos_y >> 1)); in1[2] = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, pos_y >> 1)); SR_CONV_2x2_CORE(3, out[0].lo, out[0].hi); SR_CONV_2x2_CORE(0, out[1].lo, out[1].hi); pos_y = y + 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); SR_CONV_2x2_CORE(6, out[0].lo, out[0].hi); SR_CONV_2x2_CORE(3, out[1].lo, out[1].hi); pos_y = y + 2; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1[0] = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, pos_y >> 1)); in1[1] = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, pos_y >> 1)); in1[2] = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, pos_y >> 1)); SR_CONV_2x2_CORE(6, out[1].lo, out[1].hi); out[0] *= (DATA_TYPE)(255.0f); out[1] *= (DATA_TYPE)(255.0f); int pos = mad24(y, stride, x*4); vstore8(convert_uchar8_sat(out[0]), 0, dstImg + pos); vstore8(convert_uchar8_sat(out[1]), 0, dstImg + pos + stride); } }
00059a87  #define SR_CONV_2x2_CORE_LINEAR(offset, out0, out1) \
00059abe  w[0] = VLD2(offset + 0, weight_bias); \
00059ae7  w[1] = VLD2(offset + 1, weight_bias); \
00059b10  w[2] = VLD2(offset + 2, weight_bias); \
00059b39  out0 = mad((DATA_TYPE4)(in0[0].w, in0[1].x, in0[1].y, in0[1].z), w[0].x, out0); \
00059b8c  out1 = mad((DATA_TYPE4)(in0[1].w, in0[2].x, in0[2].y, in0[2].z), w[0].x, out1); \
00059bdf  out0 = mad(in0[1], w[1].x, out0); \
00059c04  out1 = mad(in0[2], w[1].x, out1); \
00059c29  out0 = mad((DATA_TYPE4)(in0[1].y, in0[1].z, in0[1].w, in0[2].x), w[2].x, out0); \
00059c7c  out1 = mad((DATA_TYPE4)(in0[2].y, in0[2].z, in0[2].w, in0[3].x), w[2].x, out1); \
00059ccf  out0 = mad((DATA_TYPE4)(in1.s8, in1.s1, in1.s9, in1.s2), w[0].y, out0); \
00059d1a  out1 = mad((DATA_TYPE4)(in1.sa, in1.s3, in1.sb, in1.s4), w[0].y, out1); \
00059d65  out0 = mad((DATA_TYPE4)(in1.s1, in1.s9, in1.s2, in1.sa), w[1].y, out0); \
00059db0  out1 = mad((DATA_TYPE4)(in1.s3, in1.sb, in1.s4, in1.sc), w[1].y, out1); \
00059dfb  out0 = mad((DATA_TYPE4)(in1.s9, in1.s2, in1.sa, in1.s3), w[2].y, out0); \
00059e46  out1 = mad((DATA_TYPE4)(in1.sb, in1.s4, in1.sc, in1.s5), w[2].y, out1); \
00059e94  __kernel void sr_conv_2x2_s1x1_n1_c2(__read_only image2d_t srcImg0, __read_only image2d_t srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(26 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE8 out[2]; DATA_TYPE2 w[3]; DATA_TYPE4 in0[4]; DATA_TYPE16 inA, inB, in1; int width_in_1 = (width >> 1); int height_in_1 = (height >> 1); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { DATA_TYPE bias = VLD(18, weight_bias); out[0] = (DATA_TYPE8)(bias); out[1] = out[0]; x1 = (x << 1); y1 = y >> 1; inB.s3210 = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, y1)); inB.s1234 = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, y1)); inB.s5 = inB.s4; if (x1 + 4 < width_in_1) inB.s5678 = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, y1)); inB.hi = (inB.s12345678 + inB.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inB.s5 = 0.0f; if (y > 0) { y1 = (y - 1) >> 1; inA.s3210 = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, y1)); inA.s1234 = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, y1)); inA.s5 = inA.s4; if (x1 + 4 < width_in_1) inA.s5678 = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, y1)); inA.hi = (inA.s12345678 + inA.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inA.s5 = 0.0f; pos_y = y - 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = (inA + inB)*(DATA_TYPE)(0.5f); SR_CONV_2x2_CORE_LINEAR(0, out[0].lo, out[0].hi); } pos_y = y + 0; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = inB; SR_CONV_2x2_CORE_LINEAR(3, out[0].lo, out[0].hi); SR_CONV_2x2_CORE_LINEAR(0, out[1].lo, out[1].hi); pos_y = y + 1; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); inA = inB; y1 = ((y + 2) >> 1); if (y1 < height_in_1) { inA.s3210 = READ_IMAGE(srcImg1, sampler, (int2)((x - 1) >> 1, y1)); inA.s1234 = READ_IMAGE(srcImg1, sampler, (int2)((x + 1) >> 1, y1)); inA.s5 = inA.s4; if (x1 + 4 < width_in_1) inA.s5678 = READ_IMAGE(srcImg1, sampler, (int2)((x + 3) >> 1, y1)); inA.hi = (inA.s12345678 + inA.lo)*(DATA_TYPE)(0.5f); if (out_x + 7 == width - 1) inA.s5 = 0.0f; } in1 = (inA + inB)*(DATA_TYPE)(0.5f); SR_CONV_2x2_CORE_LINEAR(6, out[0].lo, out[0].hi); SR_CONV_2x2_CORE_LINEAR(3, out[1].lo, out[1].hi); if (y + 1 < height - 1) { pos_y = y + 2; in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x - 1, pos_y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, pos_y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, pos_y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, pos_y)); in1 = inA; SR_CONV_2x2_CORE_LINEAR(6, out[1].lo, out[1].hi); } out[0] = mad(out[0], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out[1] = mad(out[1], (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); int pos = mad24(y, stride, x * 4); vstore8(convert_uchar8_sat(out[0]), 0, dstImg + pos); vstore8(convert_uchar8_sat(out[1]), 0, dstImg + pos + stride); } }
0005acb1 __kernel void sr_conv_3x3_s1x1_n1_c4(__read_only image2d_t srcImg, __global DATA_TYPE *dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(40 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = (get_global_id(0) << 1); int y = (get_global_id(1) << 2); DATA_TYPE2 out0, out1, out2, out3; DATA_TYPE4 in0, in1, in2, in3; DATA_TYPE4 w0, w1, w2; if (x < width && y < height) { out0.s0 = VLD(0, weight_bias + 36); out0.s1 = out0.s0; out1 = out0; out2 = out0; out3 = out0; in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y - 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y - 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y - 1)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y - 1)); w0 = VLD4(0, weight_bias); w1 = VLD4(1, weight_bias); w2 = VLD4(2, weight_bias); out0.s0 += dot(w0, in0); out0.s0 += dot(w1, in1); out0.s0 += dot(w2, in2); out0.s1 += dot(w0, in1); out0.s1 += dot(w1, in2); out0.s1 += dot(w2, in3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 0)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 0)); out1.s0 += dot(w0, in0); out1.s0 += dot(w1, in1); out1.s0 += dot(w2, in2); out1.s1 += dot(w0, in1); out1.s1 += dot(w1, in2); out1.s1 += dot(w2, in3); w0 = VLD4(3, weight_bias); w1 = VLD4(4, weight_bias); w2 = VLD4(5, weight_bias); out0.s0 += dot(w0, in0); out0.s0 += dot(w1, in1); out0.s0 += dot(w2, in2); out0.s1 += dot(w0, in1); out0.s1 += dot(w1, in2); out0.s1 += dot(w2, in3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 1)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 1)); out1.s0 += dot(w0, in0); out1.s0 += dot(w1, in1); out1.s0 += dot(w2, in2); out1.s1 += dot(w0, in1); out1.s1 += dot(w1, in2); out1.s1 += dot(w2, in3); w0 = VLD4(6, weight_bias); w1 = VLD4(7, weight_bias); w2 = VLD4(8, weight_bias); out0.s0 += dot(w0, in0); out0.s0 += dot(w1, in1); out0.s0 += dot(w2, in2); out0.s1 += dot(w0, in1); out0.s1 += dot(w1, in2); out0.s1 += dot(w2, in3); w0 = VLD4(0, weight_bias); w1 = VLD4(1, weight_bias); w2 = VLD4(2, weight_bias); out2.s0 += dot(w0, in0); out2.s0 += dot(w1, in1); out2.s0 += dot(w2, in2); out2.s1 += dot(w0, in1); out2.s1 += dot(w1, in2); out2.s1 += dot(w2, in3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 2)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 2)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 2)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 2)); out3.s0 += dot(w0, in0); out3.s0 += dot(w1, in1); out3.s0 += dot(w2, in2); out3.s1 += dot(w0, in1); out3.s1 += dot(w1, in2); out3.s1 += dot(w2, in3); w0 = VLD4(6, weight_bias); w1 = VLD4(7, weight_bias); w2 = VLD4(8, weight_bias); out1.s0 += dot(w0, in0); out1.s0 += dot(w1, in1); out1.s0 += dot(w2, in2); out1.s1 += dot(w0, in1); out1.s1 += dot(w1, in2); out1.s1 += dot(w2, in3); w0 = VLD4(3, weight_bias); w1 = VLD4(4, weight_bias); w2 = VLD4(5, weight_bias); out2.s0 += dot(w0, in0); out2.s0 += dot(w1, in1); out2.s0 += dot(w2, in2); out2.s1 += dot(w0, in1); out2.s1 += dot(w1, in2); out2.s1 += dot(w2, in3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 3)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 3)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 3)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 3)); out3.s0 += dot(w0, in0); out3.s0 += dot(w1, in1); out3.s0 += dot(w2, in2); out3.s1 += dot(w0, in1); out3.s1 += dot(w1, in2); out3.s1 += dot(w2, in3); w0 = VLD4(6, weight_bias); w1 = VLD4(7, weight_bias); w2 = VLD4(8, weight_bias); out2.s0 += dot(w0, in0); out2.s0 += dot(w1, in1); out2.s0 += dot(w2, in2); out2.s1 += dot(w0, in1); out2.s1 += dot(w1, in2); out2.s1 += dot(w2, in3); in0 = READ_IMAGE(srcImg, sampler, (int2)(x - 1, y + 4)); in1 = READ_IMAGE(srcImg, sampler, (int2)(x + 0, y + 4)); in2 = READ_IMAGE(srcImg, sampler, (int2)(x + 1, y + 4)); in3 = READ_IMAGE(srcImg, sampler, (int2)(x + 2, y + 4)); out3.s0 += dot(w0, in0); out3.s0 += dot(w1, in1); out3.s0 += dot(w2, in2); out3.s1 += dot(w0, in1); out3.s1 += dot(w1, in2); out3.s1 += dot(w2, in3); int pos = mad24(y, stride, x); VST2(out0, 0, dstImg + pos); pos += stride; VST2(out1, 0, dstImg + pos); pos += stride; VST2(out2, 0, dstImg + pos); pos += stride; VST2(out3, 0, dstImg + pos); } }
0005be59  #define DCONV_CORE(w, offset, inA, inB, outA, outB) \
0005be90  w = VLD8(offset + 0, weight_bias); \
0005beb6  outA = mad(w.lo, inA.x, outA); \
0005bed8  outA = mad(w.hi, inA.y, outA); \
0005befa  outB = mad(w.lo, inB.x, outB); \
0005bf1c  outB = mad(w.hi, inB.y, outB); \
0005bf3e  w = VLD8(offset + 1, weight_bias); \
0005bf64  outA = mad(w.lo, inA.z, outA); \
0005bf86  outA = mad(w.hi, inA.w, outA); \
0005bfa8  outB = mad(w.lo, inB.z, outB); \
0005bfca  outB = mad(w.hi, inB.w, outB); \
0005bfef  __kernel void sr_deconv_4x4_s2x2_n4_c4(__read_only image2d_t srcImg, __global DATA_TYPE* dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(260 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1) * 2; DATA_TYPE8 out0, out1; DATA_TYPE8 w; DATA_TYPE4 in0, in1, in2, in3; if (x < width && y < height) { int pos_x = (x >> 1); int pos_y = (y - 2) >> 1; in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 0)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 0)); out0.lo = VLD4(64, weight_bias); out0.hi = out0.lo; out1 = out0; DCONV_CORE(w, 0 + 0, in0, in1, out0.lo, out1.lo); DCONV_CORE(w, 0 + 2, in1, in2, out0.hi, out1.hi); DCONV_CORE(w, 0 + 4, in1, in2, out0.lo, out1.lo); DCONV_CORE(w, 0 + 6, in2, in3, out0.hi, out1.hi); in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 1 + 0)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 1 + 0)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 1 + 0)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 1 + 0)); DCONV_CORE(w, 0 + 16, in0, in1, out0.lo, out1.lo); DCONV_CORE(w, 0 + 18, in1, in2, out0.hi, out1.hi); DCONV_CORE(w, 0 + 20, in1, in2, out0.lo, out1.lo); DCONV_CORE(w, 0 + 22, in2, in3, out0.hi, out1.hi); 
0005c603  #ifdef USE_IMAGE 
0005c617  WRITE_IMAGE(dstImg, (int2)(x + 0, y + 0), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 0), out0.hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 0), out1.lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 0), out1.hi); 
0005c6ea  #elif QUANT 
0005c6f9  int pos = mad24(y + 0, stride, x << 2); vstore16((char16)(convert_char8_sat_rte(out0), convert_char8_sat_rte(out1)), 0, (__global char*)dstBuf + pos); 
0005c793  #else 
0005c79c  int pos = mad24(y + 0, stride, x << 2); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); 
0005c807  #endif 
0005c811  out0.lo = VLD4(64, weight_bias); out0.hi = out0.lo; out1 = out0; DCONV_CORE(w, 8 + 0, in0, in1, out0.lo, out1.lo); DCONV_CORE(w, 8 + 2, in1, in2, out0.hi, out1.hi); DCONV_CORE(w, 8 + 4, in1, in2, out0.lo, out1.lo); DCONV_CORE(w, 8 + 6, in2, in3, out0.hi, out1.hi); in0 = READ_IMAGE(srcImg, sampler, (int2)(pos_x - 1, pos_y + 1 + 1)); in1 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y + 1 + 1)); in2 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y + 1 + 1)); in3 = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y + 1 + 1)); DCONV_CORE(w, 8 + 16, in0, in1, out0.lo, out1.lo); DCONV_CORE(w, 8 + 18, in1, in2, out0.hi, out1.hi); DCONV_CORE(w, 8 + 20, in1, in2, out0.lo, out1.lo); DCONV_CORE(w, 8 + 22, in2, in3, out0.hi, out1.hi); 
0005cafd  #ifdef USE_IMAGE 
0005cb11  WRITE_IMAGE(dstImg, (int2)(x + 0, y + 1), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y + 1), out0.hi); WRITE_IMAGE(dstImg, (int2)(x + 2, y + 1), out1.lo); WRITE_IMAGE(dstImg, (int2)(x + 3, y + 1), out1.hi); 
0005cbe4  #elif QUANT 
0005cbf3  pos = mad24(y + 1, stride, x << 2); vstore16((char16)(convert_char8_sat_rte(out0), convert_char8_sat_rte(out1)), 0, (__global char*)dstBuf + pos); 
0005cc89  #else 
0005cc92  pos = mad24(y + 1, stride, x << 2); vstore8(out0, 0, dstBuf + pos); vstore8(out1, 1, dstBuf + pos); 
0005ccf9  #endif 
0005cd03  } }
0005cd0a  #define SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias) \
0005cd56  w = VLD8(offset + 0, weight_bias); \
0005cd7c  out0 = mad(w, in0.s0, out0); \
0005cd9c  out1 = mad(w, in1.s0, out1); \
0005cdbc  w = VLD8(offset + 1, weight_bias); \
0005cde2  out0 = mad(w, in0.s1, out0); \
0005ce02  out1 = mad(w, in1.s1, out1); \
0005ce22  w = VLD8(offset + 2, weight_bias); \
0005ce48  out0 = mad(w, in0.s2, out0); \
0005ce68  out1 = mad(w, in1.s2, out1); \
0005ce88  w = VLD8(offset + 3, weight_bias); \
0005ceae  out0 = mad(w, in0.s3, out0); \
0005cece  out1 = mad(w, in1.s3, out1); \
0005ceee  w = VLD8(offset + 4, weight_bias); \
0005cf14  out0 = mad(w, in0.s4, out0); \
0005cf34  out1 = mad(w, in1.s4, out1); \
0005cf54  w = VLD8(offset + 5, weight_bias); \
0005cf7a  out0 = mad(w, in0.s5, out0); \
0005cf9a  out1 = mad(w, in1.s5, out1); \
0005cfba  w = VLD8(offset + 6, weight_bias); \
0005cfe0  out0 = mad(w, in0.s6, out0); \
0005d000  out1 = mad(w, in1.s6, out1); \
0005d020  w = VLD8(offset + 7, weight_bias); \
0005d046  out0 = mad(w, in0.s7, out0); \
0005d066  out1 = mad(w, in1.s7, out1); \
0005d08c  #ifdef GROUP_CONV 
0005d0a4  #define SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, offset, weight_bias) \
0005d0f0  w = VLD8((offset >> 1) + 0, weight_bias); \
0005d11d  out0.lo = mad(w.lo, in0.s0, out0.lo); \
0005d146  out1.lo = mad(w.lo, in1.s0, out1.lo); \
0005d16f  out0.hi = mad(w.hi, in0.s4, out0.hi); \
0005d198  out1.hi = mad(w.hi, in1.s4, out1.hi); \
0005d1c1  w = VLD8((offset >> 1) + 1, weight_bias); \
0005d1ee  out0.lo = mad(w.lo, in0.s1, out0.lo); \
0005d217  out1.lo = mad(w.lo, in1.s1, out1.lo); \
0005d240  out0.hi = mad(w.hi, in0.s5, out0.hi); \
0005d269  out1.hi = mad(w.hi, in1.s5, out1.hi); \
0005d292  w = VLD8((offset >> 1) + 2, weight_bias); \
0005d2bf  out0.lo = mad(w.lo, in0.s2, out0.lo); \
0005d2e8  out1.lo = mad(w.lo, in1.s2, out1.lo); \
0005d311  out0.hi = mad(w.hi, in0.s6, out0.hi); \
0005d33a  out1.hi = mad(w.hi, in1.s6, out1.hi); \
0005d363  w = VLD8((offset >> 1) + 3, weight_bias); \
0005d390  out0.lo = mad(w.lo, in0.s3, out0.lo); \
0005d3b9  out1.lo = mad(w.lo, in1.s3, out1.lo); \
0005d3e2  out0.hi = mad(w.hi, in0.s7, out0.hi); \
0005d40b  out1.hi = mad(w.hi, in1.s7, out1.hi); \
0005d437  #else 
0005d443  #define SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, offset, weight_bias) \
0005d48f  SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias) \
0005d4d6  #endif 
0005d4e6  #define SR_CONV_1x1_CORE_B(w, in0, in1, out0, out1, weight_bias) \
0005d52a  out0.lo = VLD4(8, weight_bias); \
0005d54d  out0.hi = out0.lo; \
0005d563  w = VLD8(0, weight_bias); \
0005d580  out0.lo = mad(w.lo, in0.s0, out0.lo); \
0005d5a9  out0.hi = mad(w.lo, in1.s0, out0.hi); \
0005d5d2  out0.lo = mad(w.hi, in0.s1, out0.lo); \
0005d5fb  out0.hi = mad(w.hi, in1.s1, out0.hi); \
0005d624  w = VLD8(1, weight_bias); \
0005d641  out0.lo = mad(w.lo, in0.s2, out0.lo); \
0005d66a  out0.hi = mad(w.lo, in1.s2, out0.hi); \
0005d693  out0.lo = mad(w.hi, in0.s3, out0.lo); \
0005d6bc  out0.hi = mad(w.hi, in1.s3, out0.hi); \
0005d6e5  w = VLD8(2, weight_bias); \
0005d702  out0.lo = mad(w.lo, in0.s4, out0.lo); \
0005d72b  out0.hi = mad(w.lo, in1.s4, out0.hi); \
0005d754  out0.lo = mad(w.hi, in0.s5, out0.lo); \
0005d77d  out0.hi = mad(w.hi, in1.s5, out0.hi); \
0005d7a6  w = VLD8(3, weight_bias); \
0005d7c3  out0.lo = mad(w.lo, in0.s6, out0.lo); \
0005d7ec  out0.hi = mad(w.lo, in1.s6, out0.hi); \
0005d815  out0.lo = mad(w.hi, in0.s7, out0.lo); \
0005d83e  out0.hi = mad(w.hi, in1.s7, out0.hi); \
0005d86a  __kernel void sr_conv_3x3_s1x1_n8_c8_conv_1x1_s1x1_n8_c8(__global DATA_TYPE *srcBuf, __read_only image2d_t srcImg, __global DATA_TYPE *dstBuf, __write_only image2d_t dstImg, __constant half *weight_bias_3x3 __ATTRIBUTE_MAX_CONSANT_SIZE_(585 * sizeof(half)), __constant half *weight_bias_1x1 __ATTRIBUTE_MAX_CONSANT_SIZE_(108 * sizeof(half)), int width, int height, int stride, int merge1x1) { short x = get_global_id(0) * 2; short y = get_global_id(1); DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1, in2, in3; DATA_TYPE8 w; int vstride = stride >> 3; if (x < width && y < height) { 
0005dab0  #ifdef GROUP_CONV 
0005dac5  out0 = VLD8(36, weight_bias_3x3); 
0005daea  #else 
0005daf3  out0 = VLD8(72, weight_bias_3x3); 
0005db18  #endif 
0005db22  out1 = out0; 
0005db32  #ifdef USE_IMAGE 
0005db46  const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y - 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y - 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y - 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y - 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y - 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y - 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y - 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y - 1)); 
0005ddc5  #elif QUANT 
0005ddd4  uchar16 pix0, pix1; int pos = mad24(y, vstride, x + 1); pix0 = VLD16(0, (__global unsigned char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global unsigned char*)srcBuf + (pos + 1) * 8); 
0005de93  #else
0005de9b  int pos = mad24(y, vstride, x + 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
0005df3e  #endif 
0005df4b  #if !defined(USE_IMAGE) && QUANT 
0005df6f  SR_CONV_3x3_CORE_G(w, pix0.lo, pix0.hi, out0, out1, 0, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix0.hi, pix1.lo, out0, out1, 8, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix1.lo, pix1.hi, out0, out1, 16, weight_bias_3x3); 
0005e04e  #else 
0005e057  SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, 0, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in1, in2, out0, out1, 8, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in2, in3, out0, out1, 16, weight_bias_3x3); 
0005e11e  #endif 
0005e12b  #ifdef USE_IMAGE 
0005e13f  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 1)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 1)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 1)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 1)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 1)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 1)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 1)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 1)); 
0005e342  #elif QUANT 
0005e351  pos += (vstride << 1); pix0 = VLD16(0, (__global unsigned char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global unsigned char*)srcBuf + (pos + 1) * 8); 
0005e3ef  #else 
0005e3f8  pos += (vstride << 1); in0 = vload8(pos - 1, srcBuf); in1 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in3 = vload8(pos + 2, srcBuf); 
0005e48e  #endif 
0005e49b  #if !defined(USE_IMAGE) && QUANT 
0005e4bf  SR_CONV_3x3_CORE_G(w, pix0.lo, pix0.hi, out0, out1, 48, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix0.hi, pix1.lo, out0, out1, 56, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix1.lo, pix1.hi, out0, out1, 64, weight_bias_3x3); 
0005e5a0  #else 
0005e5a9  SR_CONV_3x3_CORE_G(w, in0, in1, out0, out1, 48, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in1, in2, out0, out1, 56, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in2, in3, out0, out1, 64, weight_bias_3x3); 
0005e672  #endif 
0005e67f  #ifdef USE_IMAGE 
0005e693  in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, y + 0)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, y + 0)); in3.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, y + 0)); in3.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, y + 0)); in2.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 4, y + 0)); in2.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 5, y + 0)); in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 6, y + 0)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 7, y + 0)); 
0005e896  #elif QUANT 
0005e8a5  pos -= vstride; pix0 = VLD16(0, (__global unsigned char*)srcBuf + (pos - 1) * 8); pix1 = VLD16(0, (__global unsigned char*)srcBuf + (pos + 1) * 8); 
0005e93c  #else 
0005e945  pos -= vstride; in0 = vload8(pos - 1, srcBuf); in3 = vload8(pos + 0, srcBuf); in2 = vload8(pos + 1, srcBuf); in1 = vload8(pos + 2, srcBuf); 
0005e9d4  #endif 
0005e9e1  #if !defined(USE_IMAGE) && QUANT 
0005ea05  SR_CONV_3x3_CORE_G(w, pix0.lo, pix0.hi, out0, out1, 24, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix0.hi, pix1.lo, out0, out1, 32, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, pix1.lo, pix1.hi, out0, out1, 40, weight_bias_3x3); 
0005eae6  #else 
0005eaef  SR_CONV_3x3_CORE_G(w, in0, in3, out0, out1, 24, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in3, in2, out0, out1, 32, weight_bias_3x3); SR_CONV_3x3_CORE_G(w, in2, in1, out0, out1, 40, weight_bias_3x3); 
0005ebb8  #endif 
0005ebc2  in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); out0 = VLD8(8, weight_bias_1x1); out1 = out0; SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, 0, weight_bias_1x1); 
0005ec80  #ifdef GROUP_CONV 
0005ec95  DATA_TYPE q = weight_bias_3x3[296]; 
0005ecbc  #else 
0005ecc5  DATA_TYPE q = weight_bias_3x3[584]; 
0005ecec  #endif 
0005ecf9  #if !defined(USE_IMAGE) && QUANT 
0005ed1d  out0 = mad(convert_half8(pix0.hi), q, out0); out1 = mad(convert_half8(pix1.lo), q, out1); 
0005ed7a  #else 
0005ed83  out0 = mad(in3, q, out0); out1 = mad(in2, q, out1); 
0005edba  #endif 
0005edc4  if (merge1x1) { in0 = fmax(out0, (DATA_TYPE8)(0.0f)); in1 = fmax(out1, (DATA_TYPE8)(0.0f)); SR_CONV_1x1_CORE_B(w, in0, in1, out0, out1, weight_bias_1x1 + 72) WRITE_IMAGE(dstImg, (int2)(x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out0.hi); } else { 
0005eece  #ifdef USE_IMAGE 
0005eee2  out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); WRITE_IMAGE(dstImg, (int2)(pos_x + 2, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 3, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(pos_x + 4, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(pos_x + 5, y), out1.hi); 
0005f003  #elif QUANT 
0005f012  vstore16((uchar16)(convert_uchar8_sat_rte(out0), convert_uchar8_sat_rte(out1)), 0, (__global unsigned char*)dstBuf + pos * 8); 
0005f094  #else 
0005f09d  out0 = fmax(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)); vstore8(out0, pos + 0, dstBuf); vstore8(out1, pos + 1, dstBuf); 
0005f12e  #endif 
0005f138  } } }
0005f13f __kernel void sr_conv_3x3_s1x1_n8_c1(__global unsigned char* srcImg, OUT_TYPE dstImg, __constant half *weight_bias_prelu __ATTRIBUTE_MAX_CONSANT_SIZE_(88 * sizeof(half)), int width, int height, int stride_in, int stride_out) { int x = (get_global_id(0) << 2); int y = get_global_id(1); DATA_TYPE8 output[4], slope, sloped_out; int pos; if (x < width && y < height) { output[0] = VLD8(9, weight_bias_prelu); output[1] = output[0]; output[2] = output[0]; output[3] = output[0]; for (int i = 0; i < 3; i++) { DATA_TYPE8 weight[3]; DATA_TYPE8 in; uchar8 pix = (uchar8)(0); int pos_y = y + i - 1; if (pos_y<0 || pos_y>height - 1) continue; pos = mad24(pos_y, stride_in, x); if (x > 0) pix.s0 = srcImg[pos - 1]; pix.s1234 = vload4(0, srcImg + pos); if (x + 4<width) pix.s5 = srcImg[pos + 4]; in = CONVERT8(pix); in *= (DATA_TYPE)(1.0f / 255.0f); weight[0] = VLD8(i * 3 + 0, weight_bias_prelu); weight[1] = VLD8(i * 3 + 1, weight_bias_prelu); weight[2] = VLD8(i * 3 + 2, weight_bias_prelu); output[0] = mad(weight[0], in.s0, output[0]); output[1] = mad(weight[0], in.s1, output[1]); output[2] = mad(weight[0], in.s2, output[2]); output[3] = mad(weight[0], in.s3, output[3]); output[0] = mad(weight[1], in.s1, output[0]); output[1] = mad(weight[1], in.s2, output[1]); output[2] = mad(weight[1], in.s3, output[2]); output[3] = mad(weight[1], in.s4, output[3]); output[0] = mad(weight[2], in.s2, output[0]); output[1] = mad(weight[2], in.s3, output[1]); output[2] = mad(weight[2], in.s4, output[2]); output[3] = mad(weight[2], in.s5, output[3]); } slope = VLD8(10,weight_bias_prelu); output[0] = fmax(output[0], 0.0f) + slope * fmin(output[0], 0.0f); output[1] = fmax(output[1], 0.0f) + slope * fmin(output[1], 0.0f); output[2] = fmax(output[2], 0.0f) + slope * fmin(output[2], 0.0f); output[3] = fmax(output[3], 0.0f) + slope * fmin(output[3], 0.0f); 
0005f873  #ifdef USE_BUFFER_OUT 
0005f88c  pos = mad24(y, stride_out, x << 3); vstore8(output[0], 0, dstImg + pos); vstore8(output[1], 1, dstImg + pos); vstore8(output[2], 2, dstImg + pos); vstore8(output[3], 3, dstImg + pos); 
0005f947  #else 
0005f950  WRITE_IMAGE(dstImg, (int2)(x * 2 + 0, y), output[0].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 1, y), output[0].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 2, y), output[1].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 3, y), output[1].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 4, y), output[2].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 5, y), output[2].hi); WRITE_IMAGE(dstImg, (int2)(x * 2 + 6, y), output[3].lo); WRITE_IMAGE(dstImg, (int2)(x * 2 + 7, y), output[3].hi); 
0005fb1b  #endif 
0005fb25  } }
0005fb2a __kernel void sr_resize_2x2_add(__read_only image2d_t srcImg0, __global unsigned char* srcImg1, __global unsigned char* dstImg, int width, int height, int stride_in_1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1) * 2; DATA_TYPE4 in0[4]; DATA_TYPE16 inA, inB, out; uchar8 pix; int pos; int width_in_1 = (width >> 1); int height_in_1 = (height >> 1); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { x1 = (x << 1); pix = (uchar8)(0); y1 = (y >> 1); pos = mad24(y1, stride_in_1, x1); pix.lo = vload4(0, srcImg1 + pos); pix.s4 = pix.s3; if(x1 + 4 < width_in_1) pix.s4 = srcImg1[pos + 4]; inA.lo = CONVERT8(pix); inA.s89ab = (inA.s0123 + inA.s1234) * (DATA_TYPE)(0.5f); UGENTYPE8 mask = (UGENTYPE8)(0,4,1,5,2,6,3,7); inA.lo = shuffle2(inA.s0123, inA.s89ab, mask); inB.lo = inA.lo; if (y1 + 1 < height_in_1) { pos = mad24(y1 + 1, stride_in_1, x1); pix.lo = vload4(0, srcImg1 + pos); pix.s4 = pix.s3; if(x1 + 4 < width_in_1) pix.s4 = srcImg1[pos + 4]; inB.lo = CONVERT8(pix); inB.s89ab = (inB.s0123 + inB.s1234) * (DATA_TYPE)(0.5f); inB.lo = shuffle2(inB.s0123, inB.s89ab, mask); } inA.hi = (inA.lo + inB.lo) * (DATA_TYPE)(0.5f); inA *= (DATA_TYPE)(1.0f / 255.0f); in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 1)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 1)); out.s0123 = inA.s0123 + in0[0]; out.s4567 = inA.s4567 + in0[1]; out.s89ab = inA.s89ab + in0[2]; out.scdef = inA.scdef + in0[3]; out = mad(out, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); pos = mad24(y, stride_out, x * 4); vstore8(convert_uchar8_sat(out.lo), 0, dstImg + pos); vstore8(convert_uchar8_sat(out.hi), 0, dstImg + pos + stride_out); } }
0006029b __kernel void sr_resize_3x3_add(__read_only image2d_t srcImg0, __global unsigned char* srcImg1, __global unsigned char* dstImg, int width, int height, int stride_in_1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 3; int y = get_global_id(1) * 3; DATA_TYPE4 in0[9]; DATA_TYPE16 inA, inB, out, out1; uchar8 pix; int pos; int width_in_1 = (width / 3); int height_in_1 = (height / 3); int x1, y1, pos_y; int out_x = x * 4; int out_y = y; if (out_x < width && out_y < height) { x1 = (x * 4 / 3); pix = (uchar8)(0); y1 = (y / 3); pos = mad24(y1, stride_in_1, x1); pix.lo = vload4(0, srcImg1 + pos); pix.s4 = pix.s3; if (x1 + 4 < width_in_1) pix.s4 = srcImg1[pos + 4]; inA.lo = CONVERT8(pix); inA.s89ab = inA.s0123 * (DATA_TYPE)(0.6666666f) + inA.s1234 * (DATA_TYPE)(0.3333333f); inA.scdef = inA.s0123 * (DATA_TYPE)(0.3333333f) + inA.s1234 * (DATA_TYPE)(0.6666666f); UGENTYPE16 mask = (UGENTYPE16)(0, 8, 12, 1, 9, 13, 2, 10, 14, 3, 11, 15, 4, 5, 6, 7); inA = shuffle(inA, mask); inB = inA; if (y1 + 1 < height_in_1) { pos = mad24(y1 + 1, stride_in_1, x1); pix.lo = vload4(0, srcImg1 + pos); pix.s4 = pix.s3; if (x1 + 4 < width_in_1) pix.s4 = srcImg1[pos + 4]; inB.lo = CONVERT8(pix); inB.s89ab = inB.s0123 * (DATA_TYPE)(0.6666666f) + inB.s1234 * (DATA_TYPE)(0.3333333f); inB.scdef = inB.s0123 * (DATA_TYPE)(0.3333333f) + inB.s1234 * (DATA_TYPE)(0.6666666f); inB = shuffle(inB, mask); } out = inA * (DATA_TYPE)(0.6666666f) + inB * (DATA_TYPE)(0.3333333f); out1 = inA * (DATA_TYPE)(0.3333333f) + inB * (DATA_TYPE)(0.6666666f); inA *= (DATA_TYPE)(1.0f / 255.0f); out *= (DATA_TYPE)(1.0f / 255.0f); out1 *= (DATA_TYPE)(1.0f / 255.0f); in0[0] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y)); in0[1] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y)); in0[2] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y)); in0[3] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 1)); in0[4] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 1)); in0[5] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y + 1)); in0[6] = READ_IMAGE(srcImg0, sampler, (int2)(x + 0, y + 2)); in0[7] = READ_IMAGE(srcImg0, sampler, (int2)(x + 1, y + 2)); in0[8] = READ_IMAGE(srcImg0, sampler, (int2)(x + 2, y + 2)); inA.s0123 = inA.s0123 + in0[0]; inA.s4567 = inA.s4567 + in0[1]; inA.s89ab = inA.s89ab + in0[2]; out.s0123 = out.s0123 + in0[3]; out.s4567 = out.s4567 + in0[4]; out.s89ab = out.s89ab + in0[5]; out1.s0123 = out1.s0123 + in0[6]; out1.s4567 = out1.s4567 + in0[7]; out1.s89ab = out1.s89ab + in0[8]; inA = mad(inA, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out = mad(out, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); out1 = mad(out1, (DATA_TYPE)(255.0f), (DATA_TYPE)(0.0f)); uchar16 out_char[3]; out_char[0] = convert_uchar16_sat(inA); out_char[1] = convert_uchar16_sat(out); out_char[2] = convert_uchar16_sat(out1); pos = mad24(y, stride_out, x * 4); vstore8(out_char[0].lo, 0, dstImg + pos); vstore4(out_char[0].s89ab, 2, dstImg + pos); vstore8(out_char[1].lo, 0, dstImg + pos + stride_out); vstore4(out_char[1].s89ab, 2, dstImg + pos + stride_out); vstore8(out_char[2].lo, 0, dstImg + pos + 2 * stride_out); vstore4(out_char[2].s89ab, 2, dstImg + pos + 2 * stride_out); } }
00060f34  #define DCONV_DOT_CORE(w, offset, inA, inB, outA, outB) \
00060f6f  w = VLD8(offset + 0, weight_bias); \
00060f95  outA = mad(w.lo, inA.x, outA); \
00060fb7  outB = mad(w.lo, inB.x, outB); \
00060fd9  outA = mad(w.hi, inA.y, outA); \
00060ffb  outB = mad(w.hi, inB.y, outB); \
0006101d  w = VLD8(offset + 1, weight_bias); \
00061043  outA = mad(w.lo, inA.z, outA); \
00061065  outB = mad(w.lo, inB.z, outB); \
00061087  outA = mad(w.hi, inA.w, outA); \
000610a9  outB = mad(w.hi, inB.w, outB); \
000610ce  __kernel void sr_deconv_4x4_s2x2_n1_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(65 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0)*4; int y = get_global_id(1); DATA_TYPE4 out; DATA_TYPE8 w; DATA_TYPE4 in[4]; if (x < width && y < height) { out.s0 = VLD(64, weight_bias); out.s1 = out.s0; out.hi = out.lo; int i_start = (y & 1); int offset = i_start * 2; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in[0] = READ_IMAGE(srcImg, sampler, (int2)((x - 2) >> 1, pos_y)); in[1] = READ_IMAGE(srcImg, sampler, (int2)((x + 0) >> 1, pos_y)); in[2] = READ_IMAGE(srcImg, sampler, (int2)((x + 2) >> 1, pos_y)); in[3] = READ_IMAGE(srcImg, sampler, (int2)((x + 4) >> 1, pos_y)); w = VLD8(offset + 0, weight_bias); out.s0 += dot(w.lo, in[0]); out.s2 += dot(w.lo, in[1]); out.s1 += dot(w.hi, in[1]); out.s3 += dot(w.hi, in[2]); w = VLD8(offset + 1, weight_bias); out.s0 += dot(w.lo, in[1]); out.s2 += dot(w.lo, in[2]); out.s1 += dot(w.hi, in[2]); out.s3 += dot(w.hi, in[3]); offset += 4; } 
0006157a  #ifdef USE_BUFFER_OUT 
00061593  int pos = mad24(y, stride, x); vstore4(out, 0, dstImg + pos); 
000615d4  #else 
000615dd  WRITE_IMAGE(dstImg, (int2)(x >> 2, y), out); 
0006160d  #endif 
00061617  } } 
0006161f __kernel void sr_deconv_4x4_s2x2_n1_c4_resize_2x2_add(__read_only image2d_t srcImg0, __global unsigned char* srcImg1, __global unsigned char* dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(65 * sizeof(half)), int width, int height, int stride_in1, int stride_out) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 4; int y = get_global_id(1); DATA_TYPE4 out; DATA_TYPE8 w; DATA_TYPE4 in[4]; int width_in1 = (width >> 1); int height_in1 = (height >> 1); if (x < width && y < height) { out.s0 = VLD(64, weight_bias); out.s1 = out.s0; out.hi = out.lo; int i_start = (y & 1); int offset = i_start * 2; int pos; for (int i = 0; i < 4; i += 2) { int pos_y = ((y + i + i_start - 2) >> 1); in[0] = READ_IMAGE(srcImg0, sampler, (int2)((x - 2) >> 1, pos_y)); in[1] = READ_IMAGE(srcImg0, sampler, (int2)((x + 0) >> 1, pos_y)); in[2] = READ_IMAGE(srcImg0, sampler, (int2)((x + 2) >> 1, pos_y)); in[3] = READ_IMAGE(srcImg0, sampler, (int2)((x + 4) >> 1, pos_y)); w = VLD8(offset + 0, weight_bias); out.s0 += dot(w.lo, in[0]); out.s2 += dot(w.lo, in[1]); out.s1 += dot(w.hi, in[1]); out.s3 += dot(w.hi, in[2]); w = VLD8(offset + 1, weight_bias); out.s0 += dot(w.lo, in[1]); out.s2 += dot(w.lo, in[2]); out.s1 += dot(w.hi, in[2]); out.s3 += dot(w.hi, in[3]); offset += 4; } int x1 = (x >> 1); int y1 = (y >> 1); pos = mad24(y1, stride_in1, x1); uchar4 pix; DATA_TYPE8 inA, inB; pix.lo = vload2(0, srcImg1 + pos); pix.s2 = pix.s1; if (x1 + 2 < width_in1) pix.s2 = srcImg1[pos + 2]; inA.lo = CONVERT4(pix); inA.s45 = (inA.s01 + inA.s12)*(DATA_TYPE)(0.5f); UGENTYPE4 mask = (UGENTYPE4)(0, 2, 1, 3); inA.lo = shuffle2(inA.s01, inA.s45, mask); if ((y & 1) == 1 && y < height - 1) { pos = mad24(y1 + 1, stride_in1, x1); pix.lo = vload2(0, srcImg1 + pos); pix.s2 = pix.s1; if (x1 + 2 < width_in1) pix.s2 = srcImg1[pos + 2]; inB.lo = CONVERT4(pix); inB.s45 = (inB.s01 + inB.s12)*(DATA_TYPE)(0.5f); inB.lo = shuffle2(inB.s01, inB.s45, mask); inA.lo = (inA.lo + inB.lo)*(DATA_TYPE)(0.5f); } out += mad(out, (DATA_TYPE)(255.0f), inA.lo); pos = mad24(y, stride_out, x); vstore4(convert_uchar4_sat(out), 0, dstImg + pos); } } 
00061eb3 __kernel void sr_deconv_5x5_s3x3_n1_c4(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias __ATTRIBUTE_MAX_CONSANT_SIZE_(101 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0)*12; int y = get_global_id(1); DATA_TYPE4 out[3]; DATA_TYPE4 w; DATA_TYPE4 in[6]; if (x < width && y < height) { out[0].s0 = VLD(100, weight_bias); out[0].s1 = out[0].s0; out[0].hi = out[0].lo; out[1] = out[0]; out[2] = out[0]; int i_start = (y % 3); int effective_first_line_number = (3 - i_start) % 3; int offset = effective_first_line_number * 5; for (; effective_first_line_number < 5; effective_first_line_number += 3) { int pos_y = ((y + effective_first_line_number - 3) / 3 ); in[0] = READ_IMAGE(srcImg, sampler, (int2)((x - 3) / 3, pos_y)); in[1] = READ_IMAGE(srcImg, sampler, (int2)((x + 0) / 3, pos_y)); in[2] = READ_IMAGE(srcImg, sampler, (int2)((x + 3) / 3, pos_y)); in[3] = READ_IMAGE(srcImg, sampler, (int2)((x + 6) / 3, pos_y)); in[4] = READ_IMAGE(srcImg, sampler, (int2)((x + 9) / 3, pos_y)); in[5] = READ_IMAGE(srcImg, sampler, (int2)((x + 12) / 3, pos_y)); w = VLD4(offset + 0, weight_bias); out[0].s0 += dot(w, in[0]); out[0].s3 += dot(w, in[1]); out[1].s2 += dot(w, in[2]); out[2].s1 += dot(w, in[3]); w = VLD4(offset + 1, weight_bias); out[0].s2 += dot(w, in[1]); out[1].s1 += dot(w, in[2]); out[2].s0 += dot(w, in[3]); out[2].s3 += dot(w, in[4]); w = VLD4(offset + 2, weight_bias); out[0].s1 += dot(w, in[1]); out[1].s0 += dot(w, in[2]); out[1].s3 += dot(w, in[3]); out[2].s2 += dot(w, in[4]); w = VLD4(offset + 3, weight_bias); out[0].s0 += dot(w, in[1]); out[0].s3 += dot(w, in[2]); out[1].s2 += dot(w, in[3]); out[2].s1 += dot(w, in[4]); w = VLD4(offset + 4, weight_bias); out[0].s2 += dot(w, in[2]); out[1].s1 += dot(w, in[3]); out[2].s0 += dot(w, in[4]); out[2].s3 += dot(w, in[5]); offset += 15; } 
00062652  #ifdef USE_BUFFER_OUT 
0006266b  int pos = mad24(y, stride, x); vstore4(out[0], 0, dstImg + pos); vstore4(out[1], 1, dstImg + pos); vstore4(out[2], 2, dstImg + pos); 
000626f3  #else 
000626fc  WRITE_IMAGE(dstImg, (int2)((x >> 2), y), out[0]); WRITE_IMAGE(dstImg, (int2)((x >> 2) + 1, y), out[1]); WRITE_IMAGE(dstImg, (int2)((x >> 2) + 2, y), out[2]); 
0006279d  #endif 
000627a7  } }
000627ae  #define SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias) \
000627fa  w = VLD8(offset + 0, weight_bias); \
00062820  out0 = mad(w, in0.s0, out0); \
00062840  out1 = mad(w, in1.s0, out1); \
00062860  w = VLD8(offset + 1, weight_bias); \
00062886  out0 = mad(w, in0.s1, out0); \
000628a6  out1 = mad(w, in1.s1, out1); \
000628c6  w = VLD8(offset + 2, weight_bias); \
000628ec  out0 = mad(w, in0.s2, out0); \
0006290c  out1 = mad(w, in1.s2, out1); \
0006292c  w = VLD8(offset + 3, weight_bias); \
00062952  out0 = mad(w, in0.s3, out0); \
00062972  out1 = mad(w, in1.s3, out1); \
00062992  w = VLD8(offset + 4, weight_bias); \
000629b8  out0 = mad(w, in0.s4, out0); \
000629d8  out1 = mad(w, in1.s4, out1); \
000629f8  w = VLD8(offset + 5, weight_bias); \
00062a1e  out0 = mad(w, in0.s5, out0); \
00062a3e  out1 = mad(w, in1.s5, out1); \
00062a5e  w = VLD8(offset + 6, weight_bias); \
00062a84  out0 = mad(w, in0.s6, out0); \
00062aa4  out1 = mad(w, in1.s6, out1); \
00062ac4  w = VLD8(offset + 7, weight_bias); \
00062aea  out0 = mad(w, in0.s7, out0); \
00062b0a  out1 = mad(w, in1.s7, out1); \
00062b2d  __kernel void sr_conv_3x3_s1x1_n8_c8_prelu(__read_only image2d_t srcImg, OUT_TYPE dstImg, __global half *weight_bias_slope, int width, int height, int stride, int idx) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1); int i, j; DATA_TYPE8 out0, out1; DATA_TYPE8 in0, in1; DATA_TYPE8 w; if (x < width && y < height) { out0 = VLD8(72, weight_bias_slope); out1 = out0; short offset = 0; for (i = 0; i < 3; i++) { int pos_y = y + i - 1; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y)); for (j = 0; j < 3; j++) { in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, pos_y)); pos_x += 2; SR_CONV_3x3_CORE_B(w, in0, in1, out0, out1, offset, weight_bias_slope); offset += 8; in0 = in1; } } w = VLD8(73,weight_bias_slope); out0 = fmax(out0, (DATA_TYPE8)(0.0f)) + w * fmin(out0, (DATA_TYPE8)(0.0f)); out1 = fmax(out1, (DATA_TYPE8)(0.0f)) + w * fmin(out1, (DATA_TYPE8)(0.0f)); 
00062fa7  #ifdef USE_BUFFER_OUT 
00062fc0  int pos = mad24(y, stride, x << 3); vstore8(out0, 0, dstImg + pos); vstore8(out1, 1, dstImg + pos); 
00063027  #else 
00063030  WRITE_IMAGE(dstImg, (int2)(2 * x + 0, y), out0.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 1, y), out0.hi); WRITE_IMAGE(dstImg, (int2)(2 * x + 2, y), out1.lo); WRITE_IMAGE(dstImg, (int2)(2 * x + 3, y), out1.hi); 
00063103  #endif 
0006310d  } }
00063114  #define SR_CONV_3x3_CORE(w, in0,in1, out, offset, weight_bias) \
00063156  w = VLD4(offset + 0, weight_bias); \
0006317c  out.lo = mad(w, in0.s0, out.lo); \
000631a0  out.hi = mad(w, in1.s0, out.hi); \
000631c4  w = VLD4(offset + 1, weight_bias); \
000631ea  out.lo = mad(w, in0.s1, out.lo); \
0006320e  out.hi = mad(w, in1.s1, out.hi); \
00063232  w = VLD4(offset + 2, weight_bias); \
00063258  out.lo = mad(w, in0.s2, out.lo); \
0006327c  out.hi = mad(w, in1.s2, out.hi); \
000632a0  w = VLD4(offset + 3, weight_bias); \
000632c6  out.lo = mad(w, in0.s3, out.lo); \
000632ea  out.hi = mad(w, in1.s3, out.hi); \
0006330e  w = VLD4(offset + 4, weight_bias); \
00063334  out.lo = mad(w, in0.s4, out.lo); \
00063358  out.hi = mad(w, in1.s4, out.hi); \
0006337c  w = VLD4(offset + 5, weight_bias); \
000633a2  out.lo = mad(w, in0.s5, out.lo); \
000633c6  out.hi = mad(w, in1.s5, out.hi); \
000633ea  w = VLD4(offset + 6, weight_bias); \
00063410  out.lo = mad(w, in0.s6, out.lo); \
00063434  out.hi = mad(w, in1.s6, out.hi); \
00063458  w = VLD4(offset + 7, weight_bias); \
0006347e  out.lo = mad(w, in0.s7, out.lo); \
000634a2  out.hi = mad(w, in1.s7, out.hi); \
000634c9  __kernel void sr_conv_3x3_s1x1_n4_c8(__read_only image2d_t srcImg, OUT_TYPE dstImg, __constant half *weight_bias_3x3 __ATTRIBUTE_MAX_CONSANT_SIZE_(292 * sizeof(half)), int width, int height, int stride) { const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST; int x = get_global_id(0) * 2; int y = get_global_id(1); int i, j; DATA_TYPE8 out; DATA_TYPE8 in0, in1; DATA_TYPE4 w; if (x < width && y < height) { out.lo = VLD4(72, weight_bias_3x3); out.hi = out.lo; short offset = 0; for (i = 0; i < 3; i++) { int pos_y = y + i - 1; int pos_x = ((x - 1) << 1); in0.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 0, pos_y)); in0.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 1, pos_y)); for (j = 0; j < 3; j++) { in1.lo = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 2, pos_y)); in1.hi = READ_IMAGE(srcImg, sampler, (int2)(pos_x + 3, pos_y)); pos_x += 2; SR_CONV_3x3_CORE(w, in0, in1, out, offset, weight_bias_3x3); offset += 8; in0 = in1; } } 
000638a0  #ifdef USE_BUFFER_OUT 
000638b9  int pos = mad24(y, stride, x << 2); vstore8(out, 0, dstImg + pos); 
000638ff  #else 
00063908  WRITE_IMAGE(dstImg, (int2)(x + 0, y), out.lo); WRITE_IMAGE(dstImg, (int2)(x + 1, y), out.hi); 
00063969  #endif 
00063973  } }
000639c0 CL_DEVICE_PROFILE
000639d2 CL_DEVICE_VERSION
000639e4 CL_DEVICE_NAME
000639f3 CL_DEVICE_VENDOR
00063a04 CL_DRIVER_VERSION
00063a16 CL_DEVICE_PLATFORM
00063a29 CL_DEVICE_TYPE
00063a38 CL_DEVICE_OPENCL_C_VERSION
00063a53 CL_DEVICE_VENDOR_ID
00063a67 CL_DEVICE_MAX_COMPUTE_UNITS
00063a83 CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS
00063aa6 CL_DEVICE_MAX_WORK_GROUP_SIZE
00063ac4 CL_DEVICE_MAX_WORK_ITEM_SIZES
00063ae2 CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF
00063b08 CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR
00063b2e CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT
00063b55 CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT
00063b7a CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG
00063ba0 CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT
00063bc7 CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE
00063bef CL_DEVICE_MAX_CLOCK_FREQUENCY
00063c0d CL_DEVICE_ADDRESS_BITS
00063c24 CL_DEVICE_MAX_READ_IMAGE_ARGS
00063c42 CL_DEVICE_MAX_WRITE_IMAGE_ARGS
00063c61 CL_DEVICE_MAX_MEM_ALLOC_SIZE
00063c7e CL_DEVICE_IMAGE2D_MAX_WIDTH
00063c9a CL_DEVICE_IMAGE2D_MAX_HEIGHT
00063cb7 CL_DEVICE_IMAGE3D_MAX_DEPTH
00063cd3 CL_DEVICE_IMAGE_SUPPORT
00063ceb CL_DEVICE_MAX_PARAMETER_SIZE
00063d08 CL_DEVICE_MAX_SAMPLERS
00063d1f CL_DEVICE_MEM_BASE_ADDR_ALIGN
00063d3d CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE
00063d60 CL_DEVICE_SINGLE_FP_CONFIG
00063d7b CL_DEVICE_GLOBAL_MEM_CACHE_TYPE
00063d9b CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE
00063dbf CL_DEVICE_GLOBAL_MEM_CACHE_SIZE
00063ddf CL_DEVICE_GLOBAL_MEM_SIZE
00063df9 CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE
00063e1c CL_DEVICE_MAX_CONSTANT_ARGS
00063e38 CL_DEVICE_LOCAL_MEM_TYPE
00063e51 CL_DEVICE_LOCAL_MEM_SIZE
00063e6a CL_DEVICE_ERROR_CORRECTION_SUPPORT
00063e8d CL_DEVICE_PROFILING_TIMER_RESOLUTION
00063eb2 CL_DEVICE_ENDIAN_LITTLE
00063eca CL_DEVICE_AVAILABLE
00063ede CL_DEVICE_COMPILER_AVAILABLE
00063efb CL_DEVICE_EXECUTION_CAPABILITIES
00063f1c CL_DEVICE_QUEUE_PROPERTIES
00063f37 CL_DEVICE_HOST_UNIFIED_MEMORY
00063f55 CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR
00063f78 CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT
00063f9c CL_DEVICE_NATIVE_VECTOR_WIDTH_INT
00063fbe CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG
00063fe1 CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT
00064005 CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE
0006402a CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF
0006404d CL_DEVICE_EXTENSIONS
00064065 Not all needed cl functions found!
00064088 --clGetPlatformIDs 0
0006409d No available platforms found!
000640bb --clGetPlatformIDs 1
000640d0 Get platformID error!
000640e6 Baffin
000640ed gfx902
000640f4 --Detect platforms and devices
00064113 Get platformInfo error!
0006412b Platform vendor: 
0006413d Device Vendor:
0006414c Find prefered device:
00064162  Not prefered device, continuing......
00064189 Can not detect OpenCL platform!
000641a9 Get deviceIds error!
000641be OpenCL 2.
000641c8 Device Support OpenCL 2.0 or obove !
000641ed Device Not Support OpenCL 2.0 or obove !
00064216 Device Support SVM_FINE_GRAIN_BUFFER !
0006423d Device Not Support SVM_FINE_GRAIN_BUFFER !
00064268 Device Support SVM_FINE_GRAIN_SYSTEM !
0006428f Device Not Support SVM_FINE_GRAIN_SYSTEM !
000642ba cl_khr_fp16
000642c6 Device Support fp16 !
000642dc Device Not Support fp16 !
000642f6 Device Name is in fp16 Unsupported List, not Support fp16 !
00064332 cl_khr_image2d_from_buffer
0006434d Device Support Image from Buffer !
00064370 Device Not Support Image from Buffer !
00064397 cl_qcom_ext_host_ptr_iocoherent
000643b7 Device Support QCOM ext host iocoherent !
000643e1 Device Not Support QCOM ext host iocoherent !
0006440f cl_arm_import_memory_host
00064429 Device Support ARM import memroy Host !
00064451 Device Not Support ARM import memroy Host !
0006447d cl_khr_subgroups
0006448e Device Support KHR subgroup !
000644ac Device Not Support KHR subgroup !
000644ce Cache line size:%d
000644e2 Pitch alignment: %d pixels
000644fe Device Name:
0006450b Device Version:
0006451b --clCreateContext
0006452d Create Context error
00064542 CL Image supported: %d
0006455a Device Support RGBA-SNORM_INT8 !
0006457b Create Command Queue error
00064596  -cl-std=CL2.0
000645a5  -DHALF_FP
000645b0  -DQUALCOMM
000645bc Adreno(TM) 650
000645cb Mali-G52
000645d4 Mali-G76
000645dd Fixed Subgroup Size:%d
000645f5 CL_R
000645fa CL_A
000645ff CL_RG
00064605 CL_RA
0006460b CL_RGB
00064612 CL_RGBA
0006461a CL_BGRA
00064622 CL_ARGB
0006462a CL_INTENSITY
00064637 CL_LUMINANCE
00064644 CL_Rx
0006464a CL_RGx
00064651 CL_RGBx
00064659 CL_DEPTH
00064662 CL_DEPTH_STENCIL
00064673 CL_SNORM_INT8
00064681 CL_SNORM_INT16
00064690 CL_UNORM_INT8
0006469e CL_UNORM_INT16
000646ad CL_UNORM_SHORT_565
000646c0 CL_UNORM_SHORT_555
000646d3 CL_UNORM_INT_101010
000646e7 CL_SIGNED_INT8
000646f6 CL_SIGNED_INT16
00064706 CL_SIGNED_INT32
00064716 CL_UNSIGNED_INT8
00064727 CL_UNSIGNED_INT16
00064739 CL_UNSIGNED_INT32
0006474b CL_HALF_FLOAT
00064759 CL_FLOAT
00064762 CL_UNORM_INT24
00064771 (%s, %s)
0006477b (%d, %s)
00064785 clEngine not initialized!
000647a2 Open file 
000647ad Create Programe With Binary error!
000647d0 Build Programe Error!
000647e6 Create Kernels Error!
000647fc Create Programe With Source error!
00064822 Save bin to 
0006482f Build Programe Error!
00064846 No OpenCL source file!
0006485d UNKONW
00064864 NVIDIA
0006486b ADVANCED MICRO DEVICES
00064882 INTEL
00064888 IMAGINATION
00064894 APPLE
000648f0 Not all needed cl functions found! 
00064920 find adreno 650, disable ion buffer
00064950 not qcom adreno 650, enable ion buffer
00064980 CL Image not supported
000649a0 Start Compiling OpenCL kernels:
000649c0 import error!............
000649e0 import_host_buf_arm failed !
00064a00 Error to create SVM buffer
00064b26 .Aimg_copy_to_buf
00064b38 Can not find kernel %s
00064b50  kernel work group size:
00064b69  work_group_size:
00064b7b sub_group_size:
00064b8b  SUB-QUE  
00064b96  STA-SUB  
00064ba1  END-STA  
00064c00 libmali.so
00064c0b /system/vendor/lib64/libOpenCL.so
00064c2d /system/lib64/libOpenCL.so
00064c48 /system/vendor/lib64/egl/libGLES_mali.so
00064c71 /system/lib64/egl/libGLES_mali.so
00064c93 LoadLibraryFromPath %s successfully!
00064cb9 libion.so
00064cc3 ion_open
00064ccc Get function %s failed!
00064ce5 Get function %s successfully!
00064d04 ion_close
00064d0e ion_alloc_fd
00064d1b Load %s failed!
00064d2c Load %s succesfully!
00064d42 clGetPlatformIDs
00064d53 clGetPlatformInfo
00064d65 clBuildProgram
00064d74 clEnqueueNDRangeKernel
00064d8b clSetKernelArg
00064d9a clReleaseKernel
00064daa clCreateProgramWithSource
00064dc4 clCreateBuffer
00064dd3 clCreateImage
00064de1 clCreateImage2D
00064df1 clRetainKernel
00064e00 clCreateKernel
00064e0f clGetProgramInfo
00064e20 clFlush
00064e28 clFinish
00064e31 clReleaseProgram
00064e42 clRetainContext
00064e52 clGetContextInfo
00064e63 clCreateProgramWithBinary
00064e7d clCreateCommandQueue
00064e92 clReleaseCommandQueue
00064ea8 clEnqueueMapBuffer
00064ebb clEnqueueMapImage
00064ecd clRetainProgram
00064edd clGetProgramBuildInfo
00064ef3 clEnqueueReadBuffer
00064f07 clEnqueueWriteBuffer
00064f1c clWaitForEvents
00064f2c clReleaseEvent
00064f3b clCreateContextFromType
00064f53 clReleaseContext
00064f64 clRetainCommandQueue
00064f79 clEnqueueUnmapMemObject
00064f91 clRetainMemObject
00064fa3 clReleaseMemObject
00064fb6 clGetDeviceInfo
00064fc6 clGetDeviceIDs
00064fd5 clRetainDevice
00064fe4 clReleaseDevice
00064ff4 clRetainEvent
00065002 clGetKernelWorkGroupInfo
0006501b clGetEventInfo
0006502a clGetEventProfilingInfo
00065042 clGetImageInfo
00065051 clEnqueueCopyImage
00065064 clGetKernelInfo
00065074 clCreateKernelsInProgram
0006508d clEnqueueReadImage
000650a0 clEnqueueWriteImage
000650b4 clGetSupportedImageFormats
000650cf clEnqueueCopyImageToBuffer
000650ea clGetKernelSubGroupInfo
00065102 clGetKernelSubGroupInfoKHR
0006511d clCreateBufferFromImageQCOM
00065139 clGetDeviceImageInfoQCOM
00065152 clImportMemoryARM
00065164 clSVMAlloc
0006516f clSVMFree
00065180 Load libion.so succesfully!
000651a0 Load libion.so failed!
000651b7 /dev/ion
000651c0 ION_IOC_ALLOC error :%s 
000651da ION_IOC_NEW_ALLOC error :%s 
00065200 opening /dev/ion error 
00065220 Error with ion_open(), will use open(/dev/ion)
00065250 ioctl(m_ion_device_fd, ION_IOC_FREE, &handle_data)
00065290 Error with close(fd)
000652b0 Error with munmap()
000652d0 ION_IOC_MAP error 
000652f0 Will try use ION_IOC_NEW_ALLOC
00065310 mmap error 
0006531c CL_SUCCESS
00065327 CL_DEVICE_NOT_FOUND
0006533b CL_DEVICE_NOT_AVAILABLE
00065353 CL_COMPILER_NOT_AVAILABLE
0006536d CL_MEM_OBJECT_ALLOCATION_FAILURE
0006538e CL_OUT_OF_RESOURCES
000653a2 CL_OUT_OF_HOST_MEMORY
000653b8 CL_PROFILING_INFO_NOT_AVAILABLE
000653d8 CL_MEM_COPY_OVERLAP
000653ec CL_IMAGE_FORMAT_MISMATCH
00065405 CL_IMAGE_FORMAT_NOT_SUPPORTED
00065423 CL_BUILD_PROGRAM_FAILURE
0006543c CL_MAP_FAILURE
0006544b CL_MISALIGNED_SUB_BUFFER_OFFSET
0006546b CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST
00065498 CL_COMPILE_PROGRAM_FAILURE
000654b3 CL_LINKER_NOT_AVAILABLE
000654cb CL_LINK_PROGRAM_FAILURE
000654e3 CL_DEVICE_PARTITION_FAILED
000654fe CL_KERNEL_ARG_INFO_NOT_AVAILABLE
0006551f CL_INVALID_VALUE
00065530 CL_INVALID_DEVICE_TYPE
00065547 CL_INVALID_PLATFORM
0006555b CL_INVALID_DEVICE
0006556d CL_INVALID_CONTEXT
00065580 CL_INVALID_QUEUE_PROPERTIES
0006559c CL_INVALID_COMMAND_QUEUE
000655b5 CL_INVALID_HOST_PTR
000655c9 CL_INVALID_MEM_OBJECT
000655df CL_INVALID_IMAGE_FORMAT_DESCRIPTOR
00065602 CL_INVALID_IMAGE_SIZE
00065618 CL_INVALID_SAMPLER
0006562b CL_INVALID_BINARY
0006563d CL_INVALID_BUILD_OPTIONS
00065656 CL_INVALID_PROGRAM
00065669 CL_INVALID_PROGRAM_EXECUTABLE
00065687 CL_INVALID_KERNEL_NAME
0006569e CL_INVALID_KERNEL_DEFINITION
000656bb CL_INVALID_KERNEL
000656cd CL_INVALID_ARG_INDEX
000656e2 CL_INVALID_ARG_VALUE
000656f7 CL_INVALID_ARG_SIZE
0006570b CL_INVALID_KERNEL_ARGS
00065722 CL_INVALID_WORK_DIMENSION
0006573c CL_INVALID_WORK_GROUP_SIZE
00065757 CL_INVALID_WORK_ITEM_SIZE
00065771 CL_INVALID_GLOBAL_OFFSET
0006578a CL_INVALID_EVENT_WAIT_LIST
000657a5 CL_INVALID_EVENT
000657b6 CL_INVALID_OPERATION
000657cb CL_INVALID_GL_OBJECT
000657e0 CL_INVALID_BUFFER_SIZE
000657f7 CL_INVALID_MIP_LEVEL
0006580c CL_INVALID_GLOBAL_WORK_SIZE
00065828 CL_INVALID_PROPERTY
0006583c CL_INVALID_IMAGE_DESCRIPTOR
00065858 CL_INVALID_COMPILER_OPTIONS
00065874 CL_INVALID_LINKER_OPTIONS
0006588e CL_INVALID_DEVICE_PARTITION_COUNT
000658b0 CL_INVALID_PIPE_SIZE
000658c5 CL_INVALID_DEVICE_QUEUE
000658dd Unknown CL Error
000658ee {"%s", "%s", %d, {
00065901 {"%s", {%zu, %zu, %zu} }
0006591a --_cl_engine.Init
0006592c Output image size not match with input image size!
0006595f Tuning Kernel%d......
00065980 Input can not use arm import..... 
000659b0 Input using arm import..... 
000659d0 Output can not using arm import..... 
00065a00 Output using arm import..... 
00065a2b 3clock_gettime(CLOCK_REALTIME) failed
00065a51 clock_gettime(CLOCK_MONOTONIC) failed
00065aa0 iostream
00065aa9 unspecified iostream_category error
00065acd ios_base::clear
00065ae0 NSt6__ndk18ios_base7failureE
00065b00 NSt6__ndk18ios_baseE
00065b20 NSt6__ndk19basic_iosIcNS_11char_traitsIcEEEE
00065b50 NSt6__ndk19basic_iosIwNS_11char_traitsIwEEEE
00065b80 NSt6__ndk115basic_streambufIcNS_11char_traitsIcEEEE
00065bc0 NSt6__ndk115basic_streambufIwNS_11char_traitsIwEEEE
00065c00 NSt6__ndk113basic_istreamIcNS_11char_traitsIcEEEE
00065c40 NSt6__ndk113basic_istreamIwNS_11char_traitsIwEEEE
00065c80 NSt6__ndk113basic_ostreamIcNS_11char_traitsIcEEEE
00065cc0 NSt6__ndk113basic_ostreamIwNS_11char_traitsIwEEEE
00065d00 NSt6__ndk119__iostream_categoryE
00065d30 NSt6__ndk110__stdinbufIcEE
00065d4b unsupported locale for standard input
00065d80 NSt6__ndk110__stdinbufIwEE
00065da0 NSt6__ndk111__stdoutbufIcEE
00065dc0 NSt6__ndk111__stdoutbufIwEE
00066110 0123456789abcdefABCDEFxX+-pPiInN
00066135 money_get error
00066145 0123456789
00066150 %.0Lf
0006615a locale constructed with null
00066177 collate_byname<char>::collate_byname failed to construct for 
000661b5 collate_byname<wchar_t>::collate_byname(size_t refs) failed to construct for 
00066203 ctype_byname<char>::ctype_byname failed to construct for 
0006623d ctype_byname<wchar_t>::ctype_byname failed to construct for 
0006627a codecvt_byname<wchar_t, char, mbstate_t>::codecvt_byname failed to construct for 
000662cc false
000662d2 numpunct_byname<char>::numpunct_byname failed to construct for 
00066312 numpunct_byname<wchar_t>::numpunct_byname failed to construct for 
00066355 %a %b %d %H:%M:%S %Y
0006636a %I:%M:%S %p
00066376 time_get_byname failed to construct for 
0006639f locale not supported
000663c0 time_put_byname failed to construct for 
000663e9 moneypunct_byname failed to construct for 
00066414 Sunday
0006641b Monday
00066422 Tuesday
0006642a Wednesday
00066434 Thursday
0006643d Friday
00066444 Saturday
00066469 January
00066471 February
0006647a March
00066480 April
0006648a June
0006648f July
00066494 August
0006649b September
000664a5 October
000664ad November
000664b6 December
000664ee allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
00066532 %I:%M:%S %p
00067260 NSt6__ndk16locale5facetE
00067280 NSt6__ndk15ctypeIwEE
000672a0 NSt6__ndk110ctype_baseE
000672c0 NSt6__ndk17codecvtIcc9mbstate_tEE
000672f0 NSt6__ndk112codecvt_baseE
00067310 NSt6__ndk17codecvtIDsc9mbstate_tEE
00067340 NSt6__ndk17codecvtIDic9mbstate_tEE
00067370 NSt6__ndk17codecvtIwc9mbstate_tEE
000673a0 NSt6__ndk16locale5__impE
000673c0 NSt6__ndk17collateIcEE
000673e0 NSt6__ndk17collateIwEE
00067400 NSt6__ndk15ctypeIcEE
00067420 NSt6__ndk18numpunctIcEE
00067440 NSt6__ndk18numpunctIwEE
00067460 NSt6__ndk17num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
000674b0 NSt6__ndk19__num_getIcEE
000674d0 NSt6__ndk114__num_get_baseE
000674f0 NSt6__ndk17num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
00067540 NSt6__ndk19__num_getIwEE
00067560 NSt6__ndk17num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
000675b0 NSt6__ndk19__num_putIcEE
000675d0 NSt6__ndk114__num_put_baseE
000675f0 NSt6__ndk17num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
00067640 NSt6__ndk19__num_putIwEE
00067660 NSt6__ndk18time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
000676b0 NSt6__ndk19time_baseE
000676d0 NSt6__ndk120__time_get_c_storageIcEE
00067700 NSt6__ndk18time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
00067750 NSt6__ndk120__time_get_c_storageIwEE
00067780 NSt6__ndk18time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
000677d0 NSt6__ndk110__time_putE
000677f0 NSt6__ndk18time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
00067840 NSt6__ndk110moneypunctIcLb0EEE
00067860 NSt6__ndk110money_baseE
00067880 NSt6__ndk110moneypunctIcLb1EEE
000678a0 NSt6__ndk110moneypunctIwLb0EEE
000678c0 NSt6__ndk110moneypunctIwLb1EEE
000678e0 NSt6__ndk19money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
00067930 NSt6__ndk111__money_getIcEE
00067950 NSt6__ndk19money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
000679a0 NSt6__ndk111__money_getIwEE
000679c0 NSt6__ndk19money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
00067a10 NSt6__ndk111__money_putIcEE
00067a30 NSt6__ndk19money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
00067a80 NSt6__ndk111__money_putIwEE
00067aa0 NSt6__ndk18messagesIcEE
00067ac0 NSt6__ndk113messages_baseE
00067ae0 NSt6__ndk18messagesIwEE
00067af8 random_device failed to open 
00067b16 random_device got EOF
00067b2c random_device got an unexpected error
00067b52 basic_string
00067b5f stoul
00067b65 stoll
00067b6b stoull
00067b72 stold
00067b83 %lld
00067b88 %llu
00067b90 : no conversion
00067ba0 : out of range
00067baf string_view::substr
00067be0 generic
00067be8 unspecified generic_category error
00067c0b system
00067c12 unspecified system_category error
00067c34 Unknown error %d
00067c50 NSt6__ndk112system_errorE
00067c70 NSt6__ndk114error_categoryE
00067c90 NSt6__ndk112__do_messageE
00067cb0 NSt6__ndk124__generic_error_categoryE
00067ce0 NSt6__ndk123__system_error_categoryE
00067d05 thread::join failed
00067d19 thread::detach failed
00067d2f __thread_specific_ptr construction failed
00067d59 vector
0006b361 zPLR
00074260 Android
0007426c r19c
000742ac 5345600
00078297 >$d\<
0007829f >N1~=4
000782d5 cM?m
000782f1 hm>%I
00078372 I=B?
00078519 f:>0
00078541 j.>M
00078559 cj>@
0007856b =7#)>
000786a2 &>13
000786da 2>]^
000786f8 r \=J6X=m
00078773 =?c/
0007877a 5>6,
000787e9 L2>Oh
00078832 )=T7
00078866 %=*)U=@;5
000788b5 6+;'Sx
000788c7 =.Ft
0007894f <`j4
0007895d "W>?^
000789b6 V>T+
00078a33 =d8Q
00078a38 2TR>P
00078a5c DDy=o
00078a69 HG>[A
00078af9 <5<!@v>Qn
00078b26 u<{8Z=
00078ba4 g;q=
00078be1 Z`>`
00078bee y>]x
00078c1d 3K</
00078c88 P)0>
00078cfa 8=|7
00078d0b =PrF
00078d70 \w6>}
00078e84 eH7>
00078f84 l;s=
00078fe5 <I:P
00079015 uF<>
00079046 d<Y)
00079061 <k<cE
0007906a ]=['
00079085 mK>1
00079093 =CO3
000790c1 t9>X
000790cc ~"I<
00079106 s=$B
00079129 KP>?i
00079144 ]W%=
000791ae H=]8
000791da L> K
000792f0 QHw=v
000792f6 Y==~O
00079374 ((w=
0007938c C1>>6'2>
000793c2 k==*==_J
00079447 ?B'h;
00079493 >4^w
000794ba U=~"">
000795a9 26>Ay<
000795b4 |1+<,
0007969d @3>R
0007970a h<,v
0007971b <'H)>V=
00079733 ;T*_>
0007974c f?4>
00079755 wI=~J
00079762 f=6r*
00079785 yT=Xw
000797bd i1=7
000797db =o_m=V#
000797ec u^f>
0007980c zQk>
00079884  \R?
0007991f =FBe
00079945 w_>VZ
00079a07 =Y2G>i
00079a38 36$=
00079a78 YI8>
00079ac7 <)b;
00079b61 (*=z
00079b8e ,>!d7>
00079baf =L_.>#
00079bb7 <HU0
00079bdd j1>3
00079cb3 =M6y=o
00079ccd %J>K
00079cfc `r5;
00079d1a $=w9N=n
00079dd9 9B=2
00079e43 :^?}
00079f9b ;iWY>5xT>
00079fcd so>7
0007a03a D>Pq
0007a069 /S>\
0007a077 =V*h=
0007a083 <Mn)
0007a0e3 =`Xf>v~
0007a101 )f<.
0007a11c jrO;Y
0007a132 {>UL
0007a13a ^=P!
0007a14d [q=z5_
0007a161 4$=}
0007a1b7 =4{4=a-
0007a291 $z>^/Y
0007a30e <>u+
0007a3b1 7h=R
0007a402 L=yF
0007a41d t0=7w
0007a423 >/t"?
0007a4a0 jXc=
0007a4d7 <s#t=$
0007a51e 0>+v
0007a549 x;>Dz~<1qu>
0007a579 yZ>z\
0007a5a7 =:2 
0007a5cf =kwE
0007a641 xp>S
0007a68c bjw=
0007a6d7 =U$t
0007a6f6 N=t|<>A
0007a70f <6MJ=
0007a745 (6; 
0007a8aa '>F~m>S
0007a8bd 4y=d
0007a8cf >zip
0007a900 \^4>
0007a994 zBu>.
0007a9a1 z&>0
0007a9f5 ?\>n
0007aa5a H=EF[=
0007aa72 `>Ek
0007ab0b <za$>}
0007ab8d me>Z
0007abbb >Io{
0007abd5 yO=8
0007acaa $?Z|
0007acbb ?p8e>/G
0007ad1e |>/z
0007ad3e ~>0%
0007ad8a H>J8
0007afc2 &=>=>>
0007b098 @K/>
0007b0e9 tR>8
0007b300 B6x=
0007b310 9J*=
0007b31b >\9]=2;
0007b346 u>f+
0007b378 H6c=
0007b4a4 `	_>
0007b4f2 =>uH 
0007b51a w=~U
0007b526 z>yf
0007b659 v->=MQ>
0007b662 .>}`
0007b668  r,>
0007b71d <c>f
0007b72d Cr=e
0007b747 =tM?
0007b783 >TcC
0007b790 Ql;?
0007b7cf ? R">
0007b7e9 8J>N
0007b817 =+';>
0007b885 w^>/<
0007b897 =uIC>t^
0007b8fb ?Kf+>
0007b929 ;N>r
0007b990 D!(=L
0007ba69 3=>j
0007ba7b =1V]
0007ba96 ^=)H
0007ba9b >e29
0007bad1 X,?w
0007bb26 ^=Ny
0007bb5f >qb&>`)
0007bba0 s'5>
0007bbdf <^]R>
0007bc86 7?3C
0007bd42 ?=8  
0007bd83 =hiH
0007bd9c eG$?
0007be78 "N ?
0007be81 .&>p
0007bebe +>%e
0007bec4 =3'>[
0007bf01 )a=U)6
0007bf74 4W|>
0007bf7f >_3g>
0007bf8e ]>xMC
0007bfb2 (>?R
0007c052 v>Pi
0007c0dc rv%?
0007c104 a0$>s
0007c118 :cV>
0007c125 ls>5'.
0007c16e 1?2]K>
0007c246 L?K?
0007c27b =TA<
0007c296 {>h{
0007c2a7 >+X)>
0007c359 sF=>-U>
0007c374 ^i	>I
0007c38f >)a	
0007c3e3 =?'#
0007c3f5 \B?_
0007c431 p(>&
0007c476 "=h@^
0007c4b6 {>4n
0007c4ce +?[&
0007c4f3 <&t1
0007c516 s?eP
0007c5f2 t>Q"
0007c699 W	>@
0007c704 a/[=
0007c70b =_KN
0007c71d se>8
0007c757 >Vf%?
0007c75d n<>C
0007c7c2 9=e~|
0007c824 S0h=
0007c865 HN=Pe
0007c873 =MB{>
0007c8de X=)J 
0007c8fc d[$=
0007c912 C>4u(
0007ca2b =%hr
0007ca46 |=@s
0007ca5b >Yz_=
0007cac3 =(Gy>+
0007cace [>'}.
0007cb57 >``)
0007cb77 <xS>=T
0007cba8 *ht> 
0007cbeb =)Sq
0007cc0b > DE:
0007cd70 N67>}
0007cd9d 6T>y8F>
0007cdaf >6s+<
0007cdce q=Y'
0007cde3 >0=L<
0007ce23 =j!?>
0007ce64 bCL>
0007ce86 1>q=
0007cec1 &w;7
0007cf2a b=eY
0007d17e "=|T
0007d1a8 LL-=
0007d1d7 =g7,>
0007d21a ]>r%
0007d23b =w&Y:;
0007d25c -qI>
0007d26b ;02 
0007d283 ;5tL
0007d294 A#E?e
0007d331 P~=S
0007d34e J=%	
0007d35a B= ^
0007d37f =3Xk
0007d3b3 >~|x>8
0007d3fd 9O;~
0007d44d L,?x
0007d464 N7*=YtD=
0007d476 e>:wL
0007d489 m2>L
0007d4b1 >;>Ia
0007d4d6 B==%
0007d500 ^(e>@
0007d51e D<ID
0007d5fb >u{b
0007d635 L}<0
0007d69b >`t:=
0007d6a7 >MK$>
0007d6b7 =I`Z
0007d6ff <t0)
0007d71e j? h
0007d73c VI"=
0007d7d8 ua,=
0007d7e2 !=8Q^
0007d874 N(B<
0007d892 3=zv
0007d8de H=T'7
0007d8f6 ?>YB
0007db49 T'<'
0007db9a ?>m<
0007dbc1 C=>\/?>//D<
0007dbd2 O>5j6<
0007dc5c ,0P=
0007dd02 \=KW
0007dd91 ue;]a
0007ddce _;tc{;
0007df13 =(v~<
0007df53 <AlB
0007e000 !N/<$
0007e045 Co=E
0007e04b <8	;;
0007e053 <k|L=%
0007e176 K=J)
0007e2d6 1?%=
0007e2e4 "E<?
0007e305 5y?75l
0007e339 	B?$%
0007e343 =s-M
0007e349 3M?r+
0007e51d -g=T
0007e558 CY@>SW#
0007e576 +>YO=
0007e582 f=vo
0007e5aa G>O25=
0007e711 U'=.-T>
0007e804 P9^>R
0007e81a `;(]
0007e85b >7-M>%
0007e89e u=cx
0007e9bd WB<E
0007ea76 1<>+
0007ea80 |q9?
0007eae9 sD>W
0007eb24 UK[<
0007eb73 >48p=
0007eb8b =_"[>+*
0007eba7 =P-T>\t"
0007ec52 `>E)
0007ec72 v>2W
0007ecb8 ?^^=
0007ee05 )>= 
0007ef5b ?xwq
0007efa2 8>w/
0007efd0 2h:>
0007f001 K*>`
0007f01e o>(aY=
0007f03d %1=J]J>
0007f0a1 cJ=k
0007f0ae .=25
0007f0d8 WJ->
0007f0e7 =	6.
0007f104 9y4=
0007f13b ="hc=u
0007f145 b >)f
0007f159 "T>zZ
0007f174 gix?
0007f19e 1=44
0007f1cb >T|c
0007f2da H=jM
0007f33a }="^e>
0007f382 I=`P
0007f38a f={p
0007f429 E_=IGn=
0007f455 5[=?<W=d
0007f4a0 7]%83
0007f52a 8=}"1=f(U=
0007f535 K%=.
0007f556 ~<OY
0007f6e8 Android (5058415 based on r339409) clang version 8.0.2 (https://android.googlesource.com/toolchain/clang 40173bab62ec746213857d083c0e8b0abb568790) (https://android.googlesource.com/toolchain/llvm 7a6618d69e7e8111e1d49dc9e7813767c5ca756a) (based on LLVM 8.0.2svn)
0007f7ef Android (5220042 based on r346389c) clang version 8.0.7 (https://android.googlesource.com/toolchain/clang b55f2d4ebfd35bf643d27dbca1bb228957008617) (https://android.googlesource.com/toolchain/llvm 3c393fe7a7e13b0fba4ac75a01aa683d7a5b11cd) (based on LLVM 8.0.7svn)
0007f8f8 .init_array
0007f904 .fini_array
0007f910 .text
0007f916 .got
0007f91b .comment
0007f924 .note.android.ident
0007f938 .rela.plt
0007f942 .bss
0007f947 .dynstr
0007f94f .eh_frame_hdr
0007f95d .gnu.version_r
0007f96c .data.rel.ro
0007f979 .rela.dyn
0007f983 .gnu.version
0007f990 .dynsym
0007f998 .hash
0007f99e .eh_frame
0007f9a8 .gcc_except_table
0007f9ba .note.gnu.build-id
0007f9cd .dynamic
0007f9d6 .shstrtab
0007f9e0 .rodata
0007f9e8 .data
